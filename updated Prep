											Set 1 

What is microservice -
It is a small independent service that is used to perform specific business function



custom annotation = @retention

@Bean (@qualifier,@primary)

caching(escache, reddish, haaslecast) =  @cacheable, @cachboot, @cachevict

Types of Caching?
2 types 
	1.In Memory
	2.Distributed

Annotations in Cache?
@EnableCaching - to enable cache/caching in ur application
@Cacheable - to cache data
@CachePut - to update cache data
@CacheEvict - to delete chahce data from cache

configuration class for bean; or application.prop/YML for data source; or for server/maven we have pom.xml file => used for customization of annotation

scope => 
	1. singleton(default scope( single instatnce for entire spring container)), 
	2. prototype(new instance of bean is created as per request), 
	3. request(whatever bean is created during request is available till the request lifecycle of request), 
	4. session(it is available untill the session expires), 
	5. websocket(its for websocket session)

custom scope ?

@springbootapplication -> covers 3 annotation(@configuration,@enableautoconfiguration,@componentscan)
@enableautoconfiguration -> automatically configure spring beans based on class path dependencies to load them in container

service registory -> 
	it's a database in microservices that  holds the location of all services instances(services to register by providing ip over there and discover by itself without hardcoding); if service instance crash/shutdown then its automatically removed from the registory.
service discovery -> 

SAGA design pattern in microservices -> 
	sequence of local transaction in multiple services, each transaction updates the state within its service; 
	if  any step fails then compenseting transaction is executed to undo the previous step.
{SAGA types ->1. coreography 2. orchestation(centrally managed)}

Idempotency -> 
	multiple times we do get, put, delete it doesn't create problem(means these are idompotent) but for post multiple entries are created in database

object class is the super class of all java classes and its present in java.lang package; methods -> equals, hashcode, clone, noify, notifyall, tostring, wait

OOPS concept -> 
	inheritance, polymorphism, encapsulaion, abstraction

a single class 'Employee' behind the scene follows inheritance as by default, object class is the implementation class; also it follows polymorphism(overloading and overriding(hashcode, equals))

ArrayList -> 
	frequently data access is needed; uses dynamic array
LinkedList -> 
	frequently insertion/deletion(modify) at middle or anyplace ; it's doubly linkedlist benefit

hashmap -> 
	not thread safe, allows null keys and null values, performance is faster then chashmap
concurrent hashmap -> 
	thread safe, not allows null key and null values, performance is slow then hashmap

remove duplicate from list and preserve its order -> 1. arraylist(items) 2. iterator(arraylist(set.add.arraylist(items)));[linkedhashset(items)]

vector -> 
	introduced in java version 1.2, it's synchronized, it came before arraylist, it's threadsafe, it's less efficient, less methods present, allows 1 null value and 1 null key

volatile keyword -> 
	value of a variable will be modified by different threads, used in multithreading env. ,it ensures value visibility across the thread, Problem -> it doesn't provide automicity of read and write operation, it shows most recent value, to maintain automicity we need to use "automic" keyword.

Transient -> 
	field should not be serialized

Sring builder -> 
	mutable, not synchronized, not thread safe
String buffer -> 
	mutable, synchronized, thread safe

= =  -> 
	compares two object and check whether they point to same memory location
		
.equals -> 
	compares only values
	

difference between Serialization and Deserialization ->
Serialization - It's a process of converting an object into a format that can be stored or transmitted such as byte stream.
And these byte sream can then be save into a file or it can be send over a network or store in a database.
Basically its about the objects state making it portable so whenever we want to port the object so we use serilization process
for eg -> storing a java objects state into a file

Deserialization - It's opposite of serialization
If we want to retrieve the serialized object then we have to deserialised it first then we can read that object in same state


What annotation/liberaries we use for serialization and deserialization?
we can use serializable interface for serialization
we have libraries like jackson, gson that can handle the readable formats of data.


what challenge u have faced during serialization and deserialization?
yes 
Versioning
Performance
Security








create indexes in SQL -> 
	it's a db object helps in retrieving records very quickly and more efficiently, 
	indexing is applied to column on both table and views(declare a column as an index within a  table/view); 
	Query eg => create index index_name ON table_name column_name

indexing working internally -> 
	as query runs we can see in table index is generated , some data strucure/algorithm like B tree, hash table is used; based on algo used it scannes only few rows of tables

				
				
							SET 2

Java 8 :
- We have interface A and interface B both have Same default method;
A class implement both interfaces.
We want to print value which is in default(common) method?
Diamond problem -> compiler will throw compile time error and will ask forcefully override method and in that method say which interface method we want to call like interfaceA.super().method_name(); 

-private method in java interface?
support mostly logic of static and default method in java8.
private method came in java9
If logic is bigger in static/default then we want to separate/private the logic then we use private method in interface and that is not accessible outside interface and only that interface methods can use it so we use private method for code reusability within interface, more readable, maintainable, avoid duplication in logics

default method? -> 
	backward compatibility for older code, And don't want implementing classes to override default method as they can overrirde or can enhance the logic
	
static method? -> 
	class which are implementing static interface that cannot be overriden by implemening classess; we can call this static method by interface_name.method_name

variable argument -> 
	method to accept any number of parameter of same type then we use variable argument
	
syntax -> parameter type ...; 

psvm(String[]) -> here can we replace string array parameter in main method with variable argument.?
Yes we can replace but this is not recomended way to use

class Test {
static method()
test a = null;
a.method()
} output = ?  yes it will working

equals and hashcode contract?
whenever we override equals then we should override hashcode as well from object class

only overriding equals is not enough - explain
hashcode of object class is generated behind the scene and is used for comparison; which can have same/different values/objects so it fails to compare the equals values

base class & abstract class?
create objects, have methods, can be inherited, may or may not be extended by other class
abstract class cannot be instentiated directly, may contain or not contain abstract method

marker interface?
kind of empty interface - it does not have any methods, its kind of marking/tagging a class eg - serlizable(convert class object to byte stream), clonnable(alowed to clone but if cloneable is not implemented then thorws clone not supported exception)

custom marker interface- how to create?
define empty interface(marker interface) then have 1 class which will implement marker interface then 1 class to check if a class is implementing marker interface.

can we write functional interface without abstract method?
No, coz @functional interface must have exactly 1 abstract method, coz this method only use lambda expression and method reference

Treeset having 2 below values
1	adding null, 
2  adding object abc
Now print output?
runtime exception -> coz we added null as null values are not allowed in treeset.
coz it uses comparator internally and which has compareto() method so null compare to any object will throw nullpointer exception at runtime.

finally block will execute even if we write return statement as "system.exit()" at either in try or catch block.

different components of microservices?
service discovery -> Eureka server used to discover services for communication among the microservices.
API gateway -> act as a front door for all API's
user service -> used to handle data related to user
setting service -> used to handle all settings related to project.
histurix dashboard -> used to display information about faults in ur application.
ELK stack -> used to showcase the logs in ur application like we use elastic search.
Elastic search -> used to log the information about ur logs or application details
Logs stack -> ued to index the logs to elastic search
Kibana dashboard -> used as a console where we can see the information about our logs
load balancer
service registory
AOP
circuit brakers
Explanation- As soon as any request is made it goes to API gateway there the load balancer will be there which will root all the request to different instances of microservices,  so through API gateway it goes to service discovery(eureka) and it roots the traffic to different instances, url of this instances is dynamically generated

circuit braker pattern?
its used in microservice communication. if any microservice is down and is not able to communicate with other microservice so in this case circuit is broken so we use historic and using historic we write fallback method for microservices which is down to give service/reponse to other microservices


How u handle fault tolerance in ur microservice architecture(Circuit breaker)?
Circuit breaker pattern can be used to handle the fault tolerance
Consider there are two services and one service is calling to other end and other is calling to 3rd service (A, B, C)
consider 3 services - A is calling to B and B is calling to C but in case C is not responding so in that case we can use circuit breaker pattern to handle a failure of service A so 
we can implement a retry mechanism where if the service is down and u r trying to call that service but u r not getting response so u can try once, twice, third and then if that service is still not available then u can send a message that
this service is not available or u can configure the timeout settings.


There are 2 microservice - microservice 1, microservice 2 ; how do these microservice communicate with each other?
suppose u need some information from microservice 2 so to get info microservice 2 will call microservice 1 by using restTemplate.
So by using restTemplate.extend we can call the end point which is available in microservice like restTemplate can get the instance of restTemplate then
we can use instance.get() method which takes two parameters-(URl(end point), method type(get/post/put)) then we need RequestEntity(u r passing some request as part of Header or as a part of that request)
then u can build requestEntity by using that information
Then at the last you will get a response when u invoke that endpoint so that response is need to be captured somewhere or in some entity so that will be 4th parameter.
And using this u can give it to another microservice and get the information.

Can we do this communication in some other way like using some message broker?
yes we can use message broker for passing messages like we can use a queue or Apache Kafka where one microservice will produce the messages in that queue and the other microservice will consume that queue
So in this case -> one microservice will continuously produce the messages and the other microservice will continuously read/consume the messages
Also we have FinClient that can also be used to perform communication between microservices


interservice communication in microservice -> 
	1. sync(REst API (http(direct communication)), finclient (complex(multiple service intercommunication)), webclient(reactive programming(high concurrent application(share market data))) ) 
	2. async -> 1. message broker(rabbit mq, kafka)- calling method does not wait for response and it just move after creating/producing data ; and 2. messages and events


what is synchronous and asynchronous way of communication in microservices?
Synchrounous communication-
Synchronous communication means u r performing the operations sequentially, 1 transaction should be completed before proceding with another thransaction
Asynchronous communication- 
In asynchronous communication u can perform multiple transactions parallel so for this asynchronous communication we use Queues so one service will be producing the results and putting it into queue and the other service will read that queue continuously.

Flow of service discovery in ur project/Application?
Service Discovery is used to discover already services which are registered with that discovery server so in our application we are using Eureka server as a service discovery
So whenever there is a requst from UI or client the request goes through the API Gateway and then the
API Gateway identifies which service needs to be invoked so it needs to get the instance of that particular service so it can check the service discovery whether that instance is available or not and if that instance is available then 
you can use that instance and route that request to the particular instance of the backend service.
So basically 2 annotations are used to discover the services -
	@EnableEurekaServer - It is used over the class where ur service will act as a eureka server.
	@EnableEurekaClient - Used to make sure that this service act as a client and this service will be registered with ur eureka server and that eureka server url can be mentioned inside ur application.properties file so that it will register with that particular server
	

	
which cloud provider u have used to deploy the microservices application?
It is taken care by our build and release team.
So we basically provide our applications jar file and they use that jar file and generate the docker images and by using those docker images they deploy the application.


fault isolation
its a designed principal in a distributed system and software architecture that focuses on limiting the impact of failures within a system. so this insures the failure in one component does not cause cascading failure in other parts of the system. the main goal of this is to contain the failure within the faulty component and prevent it from the malfunctioning of entire system.

different ways to create spring boot application
using spring boot initializer (spring.io) website here we go and add all objects of dependency and it will generate project for us then we import that for our ide --- best way
using ide - sts, intellige ide
using command line interface

spring boot actuator, its end points and its advantages-
it's a module that provids production ready features so that we can monitor the health and env checks, etc . it provides various end points like - info, health, matrix, etc which is used to check spring boot health applications

Depenency injection, how it works or bean lifecycle-
3 types - constructor(mostly used) injection, setter injection and field injection
It helps in bean lifecycle by decompiling your bean creation and configuration


Spring bean(entity class)-
@bean comes in @autowired of @configuration which is for entity class
To make code more optimize we use database beans to map columns to java objects(Spring boot applications)	


Database connection in spring boot-
Add dependency of mysql in pom.xml file then define datasource- username, password in application.property file


Singleton designpattern and database connection relation between them-
we have used singleton class implementation for database connection as we need it to connect database only once.
Singleton maintains once instance only.


@transactional -
If some process is hapening and due to some reason the process got corrupted or stopped then we have to rollback the process so for this we use @transactional
@transactional best way to used is at method level not at class level.
It is used when we perform some operation in database like if we are depositing money then we use @Transactional

@transactional -> what if we write @transactional at class as well as at method level?
- method level will override the class level annotation but it is not preferred coz it will not behave properly 
So it is preferred to use at method level coz at method level we will come to know the exact issue and it will be easy to track.
@transactional is used for the methods or the process which will be executed at once and while execution if issue occurs or it gets corrupted then it needs to be rolled back.

On remote service failing how you handle rollback transactional-
Compensation transaction/distributed transaction pattern like SAGA. so we could implement SAGA Pattern here.

Notification system-
text notification through ....

JAVA Email-
3rd party service we hhave used i.e web....

Deployment in web application-
We did using AWS -
clone repo > do code change > merge code > conflict resolve manually by using head and arrows > push code to pipeline > Pipeline deploys the code
Steps in pipeline -
build > create image >.....

How Springboot simplifies the web development -
.Used to reduce boiler plate code.
.Annotations make it easier like - autowired, springbootapplication, actuators(health maintain), swagger(byforget API), more easier to maintain a web application.


Servers that springboot provides inbuilt-
tomcat(default), jetty, Undertow
We can exclude default server by excluding it from the pom.xml file.

Tools used for database migration -
flyway/liquibase
Springboot provides built in database migration tools like flyway/liquibase


Spring boot data jpa advantages over standard jpa -
It has methods like - .save, .findAll, .flash which helps to not to write quries(native quries).

Use spring data JPA, use variable search criteria by using dynamic query-
use @query and write where condition
We can use inbuilt query or custom query here as per requirement


when to use custom query-
when we have to update something based on some condition.


explain the concept of repository in Spring data JPA-
We have @Repository for database transactions.
We have different types of repository - JPA, CRUD, PagingAndSortingRepository
Based on requirement we can choose which repository we want.


Limitations of repository-?


If you have a long batch operation then how would you optimize transaction to manage performance and consistency-
We can use Cache - to enable cache(not call dal API everytime, save it in cache)
We can handle it using segments and call them using segment wise


difference in  == and .equals
== is used to compare references
.equals is used to compare contents


A scenario where .equals give false result and == gives true result.
string s1 = "Hello";
string s2 = "Hello";
if(s1 == s2) ==> True;
String s1 = "Hello";
String s2 = new String("Hello");
if(s1.equals2) = True;


Java Memory model -
It is related to thread management.
It is a abstraction that manages how threads interact through memory and how data is read from and return to main memory.


Java Memoory Management-?


explian abstraction in java?
Abstraction is where u share the relevant details with the client of the class and u hide the irrelevant details so u just share the details which is required for the client.
eg -> u r making a call from one of the class so u just give the method name and the parameters cosider the sorting, so u get list in the sorting method and how the sorting happens that is abstracted.

How do u achieve abstraction?
There r 2 ways for achieving abstraction -
1. using abstract class
2. using interface
I generally used interface for abstraction in java 


what is interface?
Interface is a contract where the class that implements interface has to bind the interface 


Use of Final keyword-
It is used to make class immutable.
If we declare a variable as final then we cannot change its value.
It can be used in immuatbility of a variable as well.
It is basically used for implementation of immutability.


How to make immutable class-
First declare class as final.
Then implement getter method only not setter method.
we can declare the variables as final.


How hashmap works.
3 steps:
1.use hash function to get the hashcode
2.initialise the bucket, means it will have formula of hashcode mode arraysize, we will get the reference number
3.storing in the bucket, whatever hashcode key is found that key we will store it there.


what happens if 2 different key have same hashcode-
hashcollision will occur and hashmap store these key in same bucket.
before java 8 all entries in same buckets were stored in linked list
after java 8 all entries are stored in a Balanced Tree in a more efficient manner.



Suppose u r storing user session data in a hashmap, how you will maintain thread safety-
we can use synchronisemap
or we can use concurrent hashmap


Explain exception handling(Checked, unchecked)
Exception handling is a mechanism to handle the errors and exception that occur in our program.
we have checked and unchecked exceptions
Unchecked Exceptions are the runtime exceptions which can be handled using the throw keyword.
Checked Exceptions are the compiled time exception this we can handle using the try catch block


How to handle where a method throws multiple types of exception-
We can use throws keyword here and mention different types of exception-
Or we can write multiple catch blocks here.

Consider a scenario where u need to choose SQL or NOSQL database then how u will choose?
SQL means ur data must be in structured manner
NOSQL means u can store the data which is not in structured manner
So we need to decide what kind of data we have means whether u r sure about number of columns if yes then SQL database if not sure then NOSQL database
consider below factors-
	data model
	consistency requirement
	how complex is the database(Entity)
	
	
How we manage database Schema like we have changes in schema then how we manage? is there any tool?
U can use tools like flyway or liquibase
Tools are basically used to write migration steps
U can even automate this migration steps as a part of your continuous integration continuous development/deployment pipelines so these tools can be used to manage these changes in ur database schema


what is unique constraint in datbase?
It indicate that the record is unique, it is basically applied on a column which will indicate that the value in that column is unique
so any other record cannot have the same value for that column



JUnit test cases-

How u do testing-
we have performed sanity testing or unit testing so we have a document where all test cases are written.


explain maven, what maven is and why we use maven?
Maven is a central repository which has all the dependencies
We use maven so that whatever dependencies we need, we mention it in our pom.xml file and when we build our code then maven will first check in our remote repository that dependencies are present or not and if it is not present then it will download it from central repository for us.


Difference between maven clean and maven install-
Maven clean is used to clean the previous build that we have had
Maven install is used to install and build the whole application again.

Few shortcuts of STS-
for debugging code we are using ctrl+shift+i to know the value of the variable.
ctrl+shift+f to make the code in a proper format.
ctrl+click to reach the end of the method/loop/class.

Which git collaboration tool u r using-
AWS 

GIT commands to resolve conflict-
We resolve it manually as we have in our code written as "head" and ">>" so what ever is between this is our previous code and the downword which is below ">>" is current code
So based on these(arrow and head) whatever we want to remove or add we accordingly manage it; and then we add it.


Difference between gitRebase and gitMerge-
When we are merging then gitMerge has the previous history and current history as well
But when we do using gitRebase it just maintain the liner history but not the previous one.

What is gitCherryPic-
When we have lot of commit but we have to take only specific one commit ahead so we use cherrypick
so its like git add only.


Write a code Using JavaStream to convert the given string into uppercase-


Adv of spring over springboot-
Spring initializer present in springboot.
configurations present in springboot.
embeded server present in springboot.

Most common Annotations you have used and their purposes-
@SpringBootApplication -> used over main method of springboot application; it's a combination of @enableautoconfiguration, @Configuration, @ComponentScan(where beans/components are located; it takes one parameter as input like package name)
@RestController -> It's used over controller layer to route the API's to their end points.
@getmapping, @putmapping, @postmapping, @deletemapping  -> These requests are used to serve the https request like get,put,post,delete.
@Autowired -> To inject the beans
etc.

How you handle exception in springboot application/global exception handler-
You can create a class globalexceptionhandler and annotate it using @RestControllerAdvice(used to handle exception at rest layer)
Inside this method return ResponseEntity
for eg u can use @ExceptionHandler Annotation for httpStatus.NOTFound ( resource not found exception)
So you can basically use @RestControllerAdvice (@ControllerAdvice) along with @ExceptionHandler, (@ResponseStatus for @controllerAdvice) to handle all exceptions
In Spring boot Exception can be handled in 3 ways-
1. Default exception handling by Spring Boot
2. Using @ExceptionHandler annotation
3. Using @ControllerAdvice for global exception handling


different status code-
404 -> API/Resource is not found
401 -> InValid Authorisation
502 -> Issue with server
403 -> Forbidden
200 -> Everything is OK


Scenario to develop a rest API and fetch data from db so explain how you will code-
put dependecy in pom.xml for database
database connection related properties like database URL, username, password, driver define/mention it in Application.property file
Then in Java code define - controller, service, DAO/Repository Layers.
In side Controller layer write - getmapping or endpoints which needs to be executed, and call service layer then call DAO/repositor layer.
In side Repository layer you can perform CRUD operations by using JPA repository.
suppose you need single record from database then use FindById function of JPA and then map this result to a bean which want to send it as a part of response.














































heartbeat
notification system in springboot application
java email
tools used in springboot for database migration are - flyway and liquibase.
























In core we have - bean configuration for proprty values of external, AOP, db configuration
Note- in core we have authenticationfilter class to do filter once(OncePerRequestFilter - springboot)
Also here we have used AOP(Aspect)


In dao we have - interfaces for CRUD operations

In dao impl we have - impl of interfaces of dao(CRUD operation) with the help of repository pkg/class or JPA CRUD operations is being performed

used serializable

In dto we have - private variables with their getter and setters

In entity we have - implemented serializable, written table name, schema name, columns declaration, getters and setters for the same columns

In mapper we have - toEntity method to save details coming from serviceimpl, toDto method to get data needed in servicimpl class

In repository we have - used @repository, @query, @transactional.... etc jpa or manual query is written for CRUD oparations on data with the help of entity class

In service we have - writtten the services interface (CRUD operations)

In service impl we have - written implementation of service interface (CRUD operations) with the help of dto(request), mapper, entity	; it does its complete implementation by using daoimpl

Generated otp using cache tokens


		








































loggers and its types.... custom logger

AOP - Spring
@exceptiononproperty, @executiononExpression annotation-
@PostConstruct
@JsonAutoDetect.... used in getter setter
@JsonDeserialize.... used in getter setter
@JsonSerialize.... used in getter setter
@JsonInclude(Include.NON_NULL).... used in getter setter
@NotEmpty
@valid
@Modifying
@Transactional
@Transactional(rollbackForClassName
@Transactional(readOnly = false)
@Transactional(transactionManager
@Transactional(timeout = 2)
SAGA pattern is used for transactional condition for rollback.
@Query
@Resource
@RequestBody
@ControllerAdvice
@SuppressWarnings
@ConditionalOnExpression
(Exception handling and its annotation)
@JsonProperty
eg ->
 public class Product {
        @JsonProperty("product_id")
        private String productId; 
        // ... getters and setters
    }
In this example, the productId field in Java will be serialized to product_id in JSON.
// Controlling Serialization/Deserialization:
It can be used to include or exclude fields or methods during the serialization and deserialization processes, providing granular control over data binding.
// The @JsonProperty annotation can be applied to:
Fields: Directly on a field within a Java class to define its corresponding JSON property name.
Getter Methods: On a getter method to control the serialization of the property.
Setter Methods: On a setter method to control the deserialization of the property.
Constructor Parameters: In conjunction with @JsonCreator, to map JSON properties to constructor parameters during object creation.








	
loadbalancer
sync and async service/API call
service mapping (1 to 1 call)
edureka server
profile creation
api gateway
method reference
cache
session

cloud - aws, azure
container - docker, kubernetes
messaging - kafka
Join(), join query/criteria
In code we have written two times left join in 1 query->
from yono_db.REKYC_CUSTOMER_INFO info " + 
			"left join yono_db.REKYC_CUSTOMER_ADDRESS adr on info.YONO_REF_NUMBER=adr.YONO_REF_NUMBER " +	
			"left join yono_db.REKYC_VCALL_DETAILS vcall on info.YONO_REF_NUMBER=vcall.YONO_REF_NUMBER " + 
			"where date(info.UPDATEDDATETIME) = :requestDate or date(info.CREATEDDATETIME) = :requestDate ";
			
			
			


Predicate => it returns true or false.
Annonymous inner class
Map reduce => 
Parralel stream



******************************************************************************************************************************
**********************************Hibernate**********************************************************

JPA and Hibernate->

ORM(Object Relational Mapping) is a tool => mapping java objects to the database tables

JDBC vs JPA vs Hibernate ::
JDBC -> Direct database interaction using SQL
JPA -> its a API specification for ORM(used by Hibernate, EclipseLink, etc); now it is renamed as Jakarta Persistance API
Hibernate -> Popular JPA implementation with advanced features; used in caching, dialect support, etc.

Hibernate Architecture::
Session factory-> 
	we create session factory once in a application as it is heavy object and can be used for whole application.
	session factory is heavy object and it is singleton in nature and used for creating sessions in a application.
Session->
	session interacts with db and session is created from session factory.
	it is light weight and short lived so it can be created and used multiple times.
Transaction->
	with the help of session we can open transaction and connect and perform - commit,rollback.
	we close the transaction after performing the operation either by closing the session or by commiting the transaction.
Query & Criteria API->
	These are used to fetch data either through complex or normal query or either by using join or projections
Hibernate config file->
	Here we write configuration of database, hibernate, class that are going to be managed by hibernate.
	This file is sent to hibernate to read and perform operations

Hibernate Workflow::
	1.Load Hibernate configuration file
	2.Create SessionFactory and this session factory should be singleton and should be created only once.
	3.Open a Session
	4.Begin Transaction
	5.Perform CRUD operations
	6.Commit Transaction
	7.Close Session
	No need to close SessionFactoryactory coz it's a singleton object and can used later on as well
	
Note - for creating sessioin factory we are using singleton design pattern

We have used rlationship of::
	@OneToOne(mappedBy = "loanAgainstMFEntity", fetch = FetchType.EAGER, cascade = CascadeType.ALL, orphanRemoval = true):-
			mappedBy => It will handle the mapping with field "loanAgainstMFEntity" without creating a new column/table for this
			fetch => Used to fetch by type eager means direct/automatically we get the result and type lazy(it is of default type) means on demand means we have to call get method to get data.
			cascade => All operations performed on parents will get affected to its child as well
			orphanRemoval => same operation is performed on child even after we get the updated data from parent
		@JoinColumn(name = "NRO_ACCOUNT_ID", referencedColumnName = "ID"):-
			This JoinColumn is used to handle the relationship with column "NRO_ACCOUNT_ID"
	@one to many
	@many to one



try with reource::
	In this try method resource is passed as an argument in try and the resource automatically gets closed.
We can get the data from table using::
	try with resource - used for creating session.
	1.Relationships - one to one, one to many, many to one, many to many
	2.HQL query
	3.Crieria API
	4.PaginationUsingHQL


******************************************************************************************************************************
********************************** Java Streams**********************************************************

Sttream creates a pipeline for map,filter(intermediate operations), etc
Stream is lazy coz it works only when terminal operation is performed or means when terminal operations hits the intermediate operations.











******************************************************************************************************************************
********************************** Java 8 features **********************************************************

what is stream?
stream is a pipeline which will be used to perform/transform the elements of stream.
suppose, there are many coloured object with multiple shapes; now you want to filter red color with rectangular shape then you can use stream and list and filter functions which are having red colour and then again use filter function which are having rectangle shape.

Itermediate operations and terminal operations in java8?
Intermediate - Used to transform the elements of a stream.eg -> filter, distinct, 
Terminal - It will give you the final result or Used to produce final result from ur stream. eg -> forEach, collect, count












******************************************************************************************************************************
********************************** Java 17 features **********************************************************
Sealed Class
	for providing restrictions on class inheritance we use sealed keyword and the class which can extend them are written in permis {eg: Sealed class A permits B, C }
	the class which extends sealed class needs to be declared as final or sealed or non sealed {eg: non sealed class B extends A } here non sealed means other class(class D ) can extend class B
	Note:: Sealed interfaces implementing interfaces need to use key word sealed or non sealedbecause final keyword is not allowed for interfaces.
	



Parallel stream.... In parallel it will process the elements.
Methods in parallel stream - 
		














******************************************************************************************************************************
********************************** Java 21 features(10) **********************************************************
Sring Templates

Unnamed Patterns and Variables

Unnamed Classes and Instance Method

Sequenced Collection Interface

Record Patterns

Pattern in switch

Virtual Threads
	Number of thread which you can create depends on your CPU memory is called virtual Threads.
	Virtual Thread is not tied to your os thread or not tied to only one OS Thread.
	Virtual Threads can be used when we need high throughput concurrent Applications.
	Virtual thread do not run code faster then platform thread , it only gives high throughput due to which it can be used.


Sequenced collection:
	 3 new interfaces added in collection in java 21 -> sequenced set, sequenced map, sequenced collection.
	 We can't remember  all collections method to get first and last element of list, queue, etc as they use different methods.
	 Sequenced collections brings uniformaty by adding methods -> addFirst(), addLast(). removeFirst(), removeLast(), reverse(); map.firstEntry(), map.lasttEntry, map.reverse(), map.sequencedKeySet(), etc{for map} to all collections(list, queue, map, etc)
	 
			











******************************************************************************************************************************
********************************** Java 24 features **********************************************************
1. Performance & Memory Management Enhancements
	1. Generational Shenanoah (Experimental)
				Related to GC
	2. Quantum-Resistant Cryptography
	3. Modernizing Java APIs
			1. Ahead of time class loading & Linking
			2. Class File API
			3. Stream Gatheres
			
	4. JVM Changes
			1. Compact Object Headers(Experimental)
			2. Restrict JNI
			3. Disable Security Manager
			
	5. Language & Syntax Enhancements
			1. Primitive Types in instanceof & switch
			2. Scoped Values(Fourth Preview)
			3. Flexible Constructor Bodies
			4. Module Import Declarations(Second Preview)
			5. Linking Run-Time Images without JMODS
			
	6. Structured Concurrency & Threading
			1. Structured Concurrency
			
	7. Deprecations & Removals
			1. Remove windows 32-bit x86 Support
			2. Deprecate 32-bit x86 Port
			
		
			
	








Controller vs restController:
Feature  				@Controller     															@RestController
Primary Use			Traditional web applications with view rendering (MVC)							RESTful web services returning data (APIs)
View Resolution		Supported; returns view names													Not supported; returns data directly
@ResponseBody		Required on methods to return data directly										Implicitly included; not required on methods
Return Type			Typically view names or ModelAndView											Typically data objects (e.g., POJOs) for serialization




@ControllerAdvice 	(Used in @ExceptionHandler):
		* Used for traditional Spring MVC applications where you are primarily returning views, and explicitly add @ResponseBody if you need to return data in specific exception handling scenarios.


		
@RestControllerAdvice  (Used in @ExceptionHandler):
		* Used for Spring RESTful services where the primary goal is to return data, as it implicitly handles the conversion of return values to the response body.



@RequestMapping:
		* It connects incoming HTTP requests to the appropriate Java methods that will handle those requests.
		* It can handle various HTTP methods (GET, POST, PUT, DELETE, etc.) by specifying the method attribute, for example, @RequestMapping(value = "/path", method = RequestMethod.POST)
		* It can be applied on 2 types:
				1.Class Level: When applied to a controller class, it defines a base URI for all methods within that controller. This helps in organizing endpoints and avoiding repetition.
				2.Method Level: When applied to a specific method within a controller, it defines the specific URI for that individual endpoint.
		* HTTP Method Specification: 
					It allows for the specification of the HTTP method (e.g., GET, POST, PUT, DELETE, PATCH) that a particular method should handle. If no method is specified, it defaults to GET.
		* Dynamic URLs: 
					It supports the use of placeholders (e.g., /{id}) in the URL path, enabling the creation of dynamic endpoints that can handle varying input values.
		* Content Type Handling: 
					It can specify the produces and consumes attributes to define the media types (e.g., application/json, application/xml) that the method can produce or consume, respectively.
		* Alternatives: 
					While @RequestMapping is versatile, Spring 4.3 and later versions introduced more specific, method-level shortcut annotations like @GetMapping, @PostMapping, @PutMapping, @DeleteMapping, and @PatchMapping for 
						improved readability and conciseness. These are often preferred for their clarity.



@path:
		* In Spring Boot, the term "@path" most commonly refers to the use of @PathVariable and the context path of the application.
		

@pathvariable (Spring MVC):
		* This annotation is used to extract values from the URI path and bind them to method parameters.
		* @PathVariable relies on @RequestMapping to define the URI template from which it extracts values.
		* @PathVariable is applied to method parameters.
		* eg- In /users/{id}, id would be a @PathVariable representing a specific user's identifier.


		
@requestparam (Spring MVC):
		* Extracts values from the query parameters of a URL. These appear after a question mark (?) in the URL as key-value pairs.
		* Primarily used for optional parameters, filtering, sorting, or pagination. It provides additional, often optional, details about how to retrieve or process a resource
		* eg- In /products?category=electronics&sort=price, category and sort would be @RequestParams
		

@PathVariable vs @RequestParam:	
Feature					@PathVariable											@RequestParam
Data Location			URI Path												Query String
Purpose					Resource identification, mandatory values				Filtering, sorting, optional parameters
URL Structure			Part of the path (e.g., /users/{id})					Key-value pairs after ? (e.g., /users?name=John)
Requirement				Typically required for resource identification			Can be optional, often used with default values
Used					When parameters are mandatory							When parameters are not mandatory	


@queryparam (JAX-RS/Jersey):
		* Extracts values from the query parameters of the URL.
		* Eg - In /products?category=electronics&limit=10, category and limit are query parameters.




		
@pathparam:
		* It is part of the JAX-RS specification for Java/Jakarta EE.
		* It is used to extract values directly from the URL path segments.
		* extracts from the path segments (e.g., /resource/{id})
		

@RequestBody:
		* @RequestBody annotation maps the HttpRequest body to a transfer or domain object, enabling automatic deserialization
		* Commonly used with requests where the payload is in structured formats like JSON or XML.

@ResponseBody:
		* It is typically used with GET methods to write the response body content.

Difference between @RequestBody and @ResponseBody
Paramaters			@RequestBody														@ResponseBody
Purpose			Applicable for the incoming request data.								Applicable for the outgoing response data.
Method body		Used with POST, PUT, PATCH methods to read the request body.			Used with GET methods to write the response body.
Return value	Typically void or a simple type											Typically, a complex object representing the response data
Object			The deserialized object is passed as a method parameter.				The serialized object is returned from the method.
Payloads		Required to read JSON/XML request payloads.								Required to write JSON/XML response payloads.		


@ModelAttribute:
		* This annotation in Spring MVC serves to bind a method parameter or method return value to a named model attribute, which is then exposed to a web view. It can be used in two primary ways:
				1.On a method parameter: @PostMapping("/submitForm")
    public String processForm(@ModelAttribute("userForm") User user) {}
				2.On a method level:  @ModelAttribute("commonData")
    public String getCommonData() {}




@CrossOrigin:
		* Cross-Origin Resource Sharing (CORS)
		* This annotation allows developers to easily manage cross-origin requests for specific handler classes or methods
		* You can apply this annotation to controllers or individual endpoints to define the allowed origins, methods, headers, and other CORS-related settings.
		
		
@Valid:
		* It triggers validation on an object or its properties, ensuring they adhere to defined constraints (e.g., @NotNull, @Size, @Min, @Max, @Pattern).
		* It is particularly useful for validating nested objects within a larger object graph.
		* It is typically placed on method arguments in controllers or service layers to validate incoming data.
		* If validation fails, a MethodArgumentNotValidException is thrown, which can be handled by a global exception handler. 



@NotNull:
		* It is used in Java Bean Validation to enforce constraints on object properties, specifically for strings.
		* @NotNull only checks for the absence of a null value, while @NotBlank provides a stricter validation for strings by also ensuring they contain at least one non-whitespace character.
		

@Entity:
		* 

Stream<Integer> vs Intstream
	???





IntStream
	Stream of primitive integer value.
	

Stream<Integer>
	Stream of integer objects.

Note->
	The list of operations available in IntStream and Stream<Integer> are diffrent.
	
	
	
System.out::println => It is commonly used with functional interfaces, particularly with the forEach method of collections, to concisely print each element.
		System is a class
		Out is a method present in System class of printstream type
		Print/println/printf is a method present in Printstream class
	// Using a lambda expression
        names.forEach(name -> System.out.println(name));

	// Using a method reference to System.out::println
        names.forEach(System.out::println);









@Column(name = "BEN_ACCOUNT_NO")
	@ColumnTransformer(read = "decrypt_char(BEN_ACCOUNT_NO,'" + Utility.ENCRYPTION_KEY + "')", write = "encrypt(?, '"
			+ Utility.ENCRYPTION_KEY + "')")
			






