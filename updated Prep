											Set 1 

custom annotation = @retention

@Bean (@qualifier,@primary)

caching(escache, reddish, haaslecast) =  @cacheable, @cachboot, @cachevict

interservice communication in microservice -> 
1. sync(REst API (http(direct communication)), finclient (complex(multiple service intercommunication)), webclient(reactive programming(high concurrent application(share market data))) ) 
and 2. async -> 1. message broker(rabbit mq, kafka)- calling method does not wait for response and it just move after creating/producing data ; and 2. messages and events

configuration class for bean; or application.prop/YML for data source; or for server/maven we have pom.xml file => used for customization of annotation

scope => singleton(default scope( single instatnce for entire spring container)), prototype(new instance of bean is created as per request), request(whatever bean is created during request is available till the request lifecycle of request), session(it is available untill the session expires), websocket(its for websocket session)

custom scope ?

@springbootapplication -> covers 3 annotation(@configuration,@enableautoconfiguration,@componentscan)
@enableautoconfiguration -> automatically configure spring beans based on class path dependencies to load them in container

service registory -> it's a database in microservices that  holds the location of all services instances(services to register by providing ip over there and discover by itself without hardcoding); if service instance crash/shutdown then its automatically removed from the registory.
service discovery -> 

SAGA design pattern in microservices -> sequence of local transaction in multiple services, each transaction updates the state within its service; if  any step fails then compenseting transaction is executed to undo the previous step.
{SAGA types ->1. coreography 2. orchestation(centrally managed)}

Idempotency -> multiple times we do get, put, delete it doesn't create problem(means these are idompotent) but for post multiple entries are created in database

object class is the super class of all java classes and its present in java.lang package; methods -> equals, hashcode, clone, noify, noifyall, tostring, wait

OOPS concept -> inheritance, polymorphism, encapsulaion, abstraction

a single class 'Employee' behind the scene follows inheritance as by default, object class is the implementation class; also it follows polymorphism(overloading and overriding(hashcode, equals))

ArrayList -> frequently data access is needed; uses dynamic array
LinkedList -> frequently insertion/deletion(modify) at middle or anyplace ; it's doubly linkedlist benefit

hashmap -> not thread safe, allows null keys and null values, performance is faster then chashmap
concurrent hashmap -> thread safe, not allows null key and null values, performance is slow then hashmap

remove duplicate from list and preserve its order -> 1. arraylist(items) 2. iterator(arraylist(set.add.arraylist(items)));[linkedhashset(items)]

vector -> introduced in java version 1.2, it's synchronized, it came before arraylist, it's threadsafe, it's less efficient, less methods present, allows 1 null value and 1 null key

volatile keyword -> value of a variable will be modified by different threads, used in multithreading env. ,it ensures value visibility across the thread, Problem -> it doesn't provide automicity of read and write operation, it shows most recent value, to maintain automicity we need to use "automic" keyword.

Transient -> field should not be serialized

Sring builder -> mutable, not synchronized, not thread safe
String buffer -> mutable, synchronized, thread safe

= = 	-> compares two object and check whether they point to same memory location
.equals -> compares only values

create indexes in SQL -> it's a db object helps in retrieving records very quickly and more efficiently, indexing is applied to column on both table and views(declare a column as an index within a  table/view); Query => create index index_name ON table_name column_name

indexing working internally -> as query runs we can see in table index is generated , some data strucure/algorithm like B tree, hash table is used; based on algo used it scannes only few rows of tables

				
				
							SET 2

Java 8 :
- We have interface A and interface B both have Same default method;
A class implement both interfaces.
We want to print value which is in default(common) method?
Diamond problem -> compiler will throw compile time error and will ask forcefully override method and in that method say which interface method we want to call like interfaceA.super().method_name(); 

-private method in java interface?
support mostly logic of static and default method in java8.
private method came in java9
If logic is bigger in static/default then we want to separate/private the logic then we use private method in interface and that is not accessible outside interface and only that interface methods can use it so we use private method for code reuability within interface, more readable, maintainable, avoid duplication in logics

default method? -> backward compatibility for older code, And don't want implementing classes to override default method as they can overrirde or can enhance the logic
static method? -> class which are implementing static interface that cannot be overriden by implemening classess; we can call this static method by interface_name.method_name

variable argument -> method to accept any number of parameter of same type then we use variable argument
syntax -> parameter type ...; 

psvm(String[]) -> here can we replace string array parameter in main method with variable argument.?
Yes we can replace but this is not recomended way to use

class Test {
static method()
test a = null;
a.method()
} output = ?  yes it will working

equals and hashcode contract?
whenever we override equals then we should override hashcode as well from object class

only overriding equals is not enough - explain
hashcode of object class is generated behind the scene and is used for comparison; which can have same/different values/objects so it fails to compare the equals values

base class & abstract class?
create objects, have methods, can be inherited, may or may not be extended by other class
abstract class cannot be instentiated directly, may contain or not contain abstract method

marker interface?
kind of empty interface - it does not have any methods, its kind of marking/tagging a class eg - serlizable(convert class object to byte stream), clonnable(alowed to clone but if cloneable is not implemented then thorws clone not supported exception)

custom marker interface- how to create?
define empty interface(marker interface) then have 1 class which will implement marker interface then 1 class to check if a class is implementing marker interface.

can we write functional interface without abstract method?
No, coz @functional interface must have exactly 1 abstract method, coz this method only use lambda expression and method reference

Treeset having 2 below values
1	adding null, 
2  adding object abc
Now print output?
runtime exception -> coz we added null as null values are not allowed in treeset.
coz it uses comparator internally and which has compareto() method so null compare to any object will throw nullpointer exception at runtime.

finally block will execute even if we write return statement as "system.exit()" at either in try or catch block.

different components of microservices?
service discovery
API gateway
load balancer
service registory
AOP
circuit brakers
Explanation- As soon as any request is made it goes to API gateway there the load balancer will be there which will root all the request to different instances of microservices,  so through API gateway it goes to service discovery(eureka) and it roots the traffic to different instances, url of this instances is dynamically generated

circuit braker pattern?
its used in microservice communication. if any microservice is down and is not able to communicate with other microservice so in this case circuit is broken so we use historic and using historic we write fallback method for microservices which is down to give service/reponse to other microservices

fault isolation
its a designed principal in a distributed system and software architecture that focuses on limiting the impact of failures within a system. so this insures the failure in one component does not cause cascading failure in other parts of the system. the main goal of this is to contain the failure within the faulty component and prevent it from the malfunctioning of entire system.

different ways to create spring boot application
using spring boot initializer (spring.io) website here we go and add all objects of dependency and it will generate project for us then we import that for our ide --- best way
using ide - sts, intellige ide
using command line interface

spring boot actuator, its end points and its advantages-
it's a module that provids production ready features so that we can monitor the health and env checks, etc . it provides various end points like - info, health, matrix, etc which is used to check spring boot health applications

Depenency injection, how it works-
3 types - constructor, setter and field

Spring bean(entity class)-
@bean comes in @autowired of @configuration which is for entity class	

Singleton designpattern and database connection relation between them-
we have used singleton class implementation for database connection as we need it to connect database only once.

@transactional -> what if we write @transactional at class as well as at method level?
- class will override the class level annotation but it is not preferred coz it will not behave properly 
So it is preferred to use at class level coz at class level we will come to know the exact issue and it will be eas to track.
@transactional is used for the methods or the process which will be executed at once and while execution if issue occurs or it gets corrupted then it needs to be rolled back.

Servers that springboot provides inbuilt-
tomcat(default), jetty, Undertow

Spring boot data jpa advantages over standard jpa -


when to use custom query over inbuilt jpa query -

concept of repository in database - 
we have - jpa, crud repository, 































heartbeat
notification system in springboot application
java email
tools used in springboot for database migration are - flyway and liquibase.
























In core we have - bean configuration for proprty values of external, AOP, db configuration
Note- in core we have authenticationfilter class to do filter once(OncePerRequestFilter - springboot)
Also here we have used AOP(Aspect)


In dao we have - interfaces for CRUD operations

In dao impl we have - impl of interfaces of dao(CRUD operation) with the help of repository pkg/class or JPA CRUD operations is being performed

used serializable

In dto we have - private variables with their getter and setters

In entity we have - implemented serializable, written table name, schema name, columns declaration, getters and setters for the same columns

In mapper we have - toEntity method to save details coming from serviceimpl, toDto method to get data needed in servicimpl class

In repository we have - used @repository, @query, @transactional.... etc jpa or manual query is written for CRUD oparations on data with the help of entity class

In service we have - writtten the services interface (CRUD operations)

In service impl we have - written implementation of service interface (CRUD operations) with the help of dto(request), mapper, entity	; it does its complete implementation by using daoimpl

Generated otp using cache tokens


		








































loggers and its types.... custom logger

AOP - Spring
@exceptiononproperty, @executiononExpression annotation-
@PostConstruct
@JsonAutoDetect.... used in getter setter
@JsonDeserialize.... used in getter setter
@JsonSerialize.... used in getter setter
@JsonInclude(Include.NON_NULL).... used in getter setter
@NotEmpty
@valid
@Modifying
@Transactional
@Transactional(rollbackForClassName
@Transactional(readOnly = false)
@Transactional(transactionManager
@Transactional(timeout = 2)
SAGA pattern is used for transactional condition for rollback.
@Query
@Resource
@RequestBody
@ControllerAdvice
@SuppressWarnings
@ConditionalOnExpression
(Exception handling and its annotation)
@PostConstruct
@JsonProperty
eg ->
 public class Product {
        @JsonProperty("product_id")
        private String productId; 
        // ... getters and setters
    }
In this example, the productId field in Java will be serialized to product_id in JSON.
// Controlling Serialization/Deserialization:
It can be used to include or exclude fields or methods during the serialization and deserialization processes, providing granular control over data binding.
// The @JsonProperty annotation can be applied to:
Fields: Directly on a field within a Java class to define its corresponding JSON property name.
Getter Methods: On a getter method to control the serialization of the property.
Setter Methods: On a setter method to control the deserialization of the property.
Constructor Parameters: In conjunction with @JsonCreator, to map JSON properties to constructor parameters during object creation.








	
loadbalancer
sync and async service/API call
service mapping (1 to 1 call)
edureka server
profile creation
api gateway
method reference
cache
session

cloud - aws, azure
container - docker, kubernetes
messaging - kafka

Join(), join query/criteria
In code we have written two times left join in 1 query->
from yono_db.REKYC_CUSTOMER_INFO info " + 
			"left join yono_db.REKYC_CUSTOMER_ADDRESS adr on info.YONO_REF_NUMBER=adr.YONO_REF_NUMBER " +	
			"left join yono_db.REKYC_VCALL_DETAILS vcall on info.YONO_REF_NUMBER=vcall.YONO_REF_NUMBER " + 
			"where date(info.UPDATEDDATETIME) = :requestDate or date(info.CREATEDDATETIME) = :requestDate ";
			
			
			


Predicate => it returns true or false.
Annonymous inner class
Map reduce => 
Parralel stream



******************************************************************************************************************************
**********************************Hibernate**********************************************************

JPA and Hibernate->

ORM(Object Relational Mapping) is a tool => mapping java objects to the database tables

JDBC vs JPA vs Hibernate ::
JDBC -> Direct database interaction using SQL
JPA -> its a API specification for ORM(used by Hibernate, EclipseLink, etc); now it is renamed as Jakarta Persistance API
Hibernate -> Popular JPA implementation with advanced features; used in caching, dialect support, etc.

Hibernate Architecture::
Session factory-> 
	we create session factory once in a application as it is heavy object and can be used for whole application.
	session factory is heavy object and it is singleton in nature and used for creating sessions in a application.
Session->
	session interacts with db and session is created from session factory.
	it is light weight and short lived so it can be created and used multiple times.
Transaction->
	with the help of session we can open transaction and connect and perform - commit,rollback.
	we close the transaction after performing the operation either by closing the session or by commiting the transaction.
Query & Criteria API->
	These are used to fetch data either through complex or normal query or either by using join or projections
Hibernate config file->
	Here we write configuration of database, hibernate, class that are going to be managed by hibernate.
	This file is sent to hibernate to read and perform operations

Hibernate Workflow::
	1.Load Hibernate configuration file
	2.Create SessionFactory and this session factory should be singleton and should be created only once.
	3.Open a Session
	4.Begin Transaction
	5.Perform CRUD operations
	6.Commit Transaction
	7.Close Session
	No need to close SessionFactoryactory coz it's a singleton object and can used later on as well
	
Note - for creating sessioin factory we are using singleton design pattern

We have used rlationship of::
	@OneToOne(mappedBy = "loanAgainstMFEntity", fetch = FetchType.EAGER, cascade = CascadeType.ALL, orphanRemoval = true):-
			mappedBy => It will handle the mapping with field "loanAgainstMFEntity" without creating a new column/table for this
			fetch => Used to fetch by type eager means direct/automatically we get the result and type lazy(it is of default type) means on demand means we have to call get method to get data.
			cascade => All operations performed on parents will get affected to its child as well
			orphanRemoval => same operation is performed on child even after we get the updated data from parent
		@JoinColumn(name = "NRO_ACCOUNT_ID", referencedColumnName = "ID"):-
			This JoinColumn is used to handle the relationship with column "NRO_ACCOUNT_ID"
	@one to many
	@many to one



try with reource::
	In this try method resource is passed as an argument in try and the resource automatically gets closed.
We can get the data from table using::
	try with resource - used for creating session.
	1.Relationships - one to one, one to many, many to one, many to many
	2.HQL query
	3.Crieria API
	4.PaginationUsingHQL


******************************************************************************************************************************
********************************** Java Streams**********************************************************

Sttream creates a pipeline for map,filter(intermediate operations), etc
Stream is lazy coz it works only when terminal operation is performed or means when terminal operations hits the intermediate operations.



Stream<Integer> vs Intstream
	???





IntStream
	Stream of primitive integer value.
	

Stream<Integer>
	Stream of integer objects.

Note->
	The list of operations available in IntStream and Stream<Integer> are diffrent.
	
	
	
System.out::println => It is commonly used with functional interfaces, particularly with the forEach method of collections, to concisely print each element.
		System is a class
		Out is a method present in System class of printstream type
		Print/println/printf is a method present in Printstream class
	// Using a lambda expression
        names.forEach(name -> System.out.println(name));

	// Using a method reference to System.out::println
        names.forEach(System.out::println);









@Column(name = "BEN_ACCOUNT_NO")
	@ColumnTransformer(read = "decrypt_char(BEN_ACCOUNT_NO,'" + Utility.ENCRYPTION_KEY + "')", write = "encrypt(?, '"
			+ Utility.ENCRYPTION_KEY + "')")
			










