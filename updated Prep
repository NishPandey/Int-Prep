											Set 1 

S -> SRP means one class one responsibility
O -> OCP means extend without modifying
L -> LSP means Child should replace parent
I -> ISP means prefer small, client-specific interfaces
D -> DIP means depend on abstraction not implementation


Difference between Spring boot and Spring MVC?
Spring MVC : is basically model view controller and its a web framework and its a part of whole spring framework. It allows developers to build web application and restful services using MVC design pattern.
Spring boot : This frame work is built on top of Spring and it uses Spring MVC internally but it provides some additional things like Autoconfiguration, bolier plate code has been removed, embeded server have like -> Tomcat, Jetty, undertow; Starter dependency, there is no xml configuration required.

What is microservice -
It is a small independent service that is used to perform specific business function



Monolithic projects needs to be created when project is small to medium, simple and  we don't have strong devops or cloud infra team.
	1.Tight coupling of services:
		If 1 service is down other services also get affected
		If 1 service is planned to redeploy other also get affected
	2.Scaling problem (cannot extend project if needed in future)
	3.Technology locking (other technology services issue)
	4.Codebase become complex as project scale.
	5.Modern monolithic(Spring boot) provide inbuilt server.
	
Microservice projects needs to be created when project is Large and complex, needs to scale, agility and resilience is needed then for this we must needs to have strong devops team as well.
In microservices to handle all request API from client we use - API Gateway
We use Service Registory/Discovery server to manage all information of all API instance, load balancing, service ID, API present in project like API gateway dteails, and other services api url.
We use config server to configure servers for calling another API means we are using config server to exernalise the configurations of all API at one place
We have internal inbuilt server as by default.
For internal service communication we use communication over HTTP or other way of communication.
For tracing logs centrally means tracing logs of all services at one place we use Zipkin [view service through interface] and Sleuth(Spring cloud)[distributor tracing purpose]

Scalability : For monolithic we have to scale whole application but for microservices we can scale independent microservices.
Advance Technology : We have to use single technology for developing whole application, we cannot change it but in microservices we can use java, python, etc technology different different services and different databases can be used.




custom annotation = @retention

How we create custom annotation?
There are ways, we should use target retention, these annotations.

We can define custom annotation and annotate it with @component or another stereotype

@Bean (@qualifier,@primary).
@qualifier :
@primary : 

Bean life cycle?
1.	Bean Definition Loading: 
Spring reads the bean definitions from configuration metadata (e.g., XML, Java annotations, or Java configuration) to understand how to create and configure the beans.
2.	Bean Instantiation: 
The Spring container creates an instance of the bean, typically by invoking its constructor.
3.	Dependency Injection: 
After instantiation, the container injects any required dependencies into the bean, either through constructor injection, setter injection, or field injection.
4.	Bean Initialization: 
This stage involves preparing the bean for use. It can include:
a.	BeanNameAware and BeanFactoryAware / ApplicationContextAware callbacks: If the bean implements these interfaces, Spring injects the bean's name, the BeanFactory, or the ApplicationContext respectively.
b.	BeanPostProcessor.postProcessBeforeInitialization(): Custom logic can be executed by BeanPostProcessors before any initialization methods are called.
c.	@PostConstruct or init-method: If defined, methods annotated with @PostConstruct or specified as init-method in the configuration are invoked for custom initialization logic.
d.	InitializingBean.afterPropertiesSet(): If the bean implements InitializingBean, its afterPropertiesSet() method is called.
5.	Bean Usage: 
The fully initialized bean is now ready for use by the application and can interact with other components.
6.	Bean Destruction: 
When the Spring container is shut down, or a bean is no longer needed, the destruction phase occurs. This can involve:
a.	@PreDestroy or destroy-method: If defined, methods annotated with @PreDestroy or specified as destroy-method are invoked for custom cleanup logic.
b.	DisposableBean.destroy(): If the bean implements DisposableBean, its destroy() method is called. 
c.	BeanPostProcessor.postProcessBeforeDestruction(): Custom logic can be executed by BeanPostProcessors before the bean is destroyed.

What is bean?
	It is a spring boot object which spring boot takes care of it.
	The Spring IoC container is responsible for the entire lifecycle of a bean, including its creation, configuration, and destruction. This "inversion of control" means that instead of your code directly creating and managing object dependencies, the container handles it. So IOC containers uses Metadata. This metadata spring creates and wires bean runtime.  So all this data gets stored in the metadata – bean creation, configuration, we just give the annotations and then these things gets stored in the metadata and then IOC container looks the metadata and just take help and just do things.
	Configuration: Beans are defined through configuration metadata. 
	This can be done using:
	1.XML-based configuration: Defining beans and their dependencies in XML files.
	2.Annotation-based configuration: Using annotations like @Component, @Service, @Repository, @Controller, and @Bean within Java classes to mark them as Spring beans.
	3.Java-based configuration: Using @Configuration classes and @Bean methods to programmatically define beans.
	Scope: Beans can have different scopes, defining how many instances of a bean are created and when they are available. 
	Common scopes include:
	1.Singleton (default): Only one instance of the bean is created per Spring IoC container and shared across the entire application.
	2.Prototype: A new instance of the bean is created each time it is requested.
	3.Request, Session, Application: Scopes specific to web applications.

Can we interchange @repository with @service?
Yes we can but its not a good practice.

Difference between application context and bean factory?
Both BeanFactory and ApplicationContext serve as Inversion of Control (IoC) containers in Spring, responsible for managing the lifecycle and dependencies of beans. However, ApplicationContext is a more advanced and feature-rich extension of BeanFactory. BeanFactory provides the core functionality of an IoC container
Application context : We use in the main method, we call the run() method by application context. Application context is a superset of bean factory.
Bean Factory : It is basic DI container. It works in initialization, it’s a light wait

Scenario when to use Bean Factory over Application Context?
In memory consent environment where fully application context features  are not needed for simple stand alone application we go for bean factory.

What is Spring IOC Container?
The Spring IoC (Inversion of Control) container is a core component of the Spring Framework, responsible for managing the lifecycle of Java objects, known as "beans." It implements the Inversion of Control principle, where the framework, rather than the application code, takes control of creating, configuring, and assembling objects and their dependencies.
It does below tasks-
	i.Object Creation and Management: 
	ii.Dependency Injection (DI):
	iii.Configuration: 
iv.Lifecycle Management: 

Did u faced any Circular dependency issue and how u resolved it?
A circular dependency occurs when two classes depend on each other. For example, class A needs class B, and class B also needs class A. 
we can address the problem by changing the way our beans are wired – to use setter injection (or field injection) instead of constructor injection. This way, Spring creates the beans, but the dependencies aren't injected until they are needed.

Difference between JPA repository and CRUD repository?
In Spring Data JPA, CrudRepository and JpaRepository are interfaces that provide different levels of functionality for data access.
JPA repository :
•	JpaRepository extends PagingAndSortingRepository, which in turn extends CrudRepository.
•	Therefore, JpaRepository inherits all the methods from both CrudRepository and PagingAndSortingRepository.
•	Examples of additional methods in JpaRepository include flush(), saveAndFlush(), deleteInBatch(), and methods that accept Pageable and Sort objects for pagination and sorting.

CRUD repository : 
•	CrudRepository is a foundational interface that provides basic Create, Read, Update, and Delete (CRUD) operations.
•	It offers methods like save(), findById(), findAll(), delete(), and count().


How u have used logging in ur project?
Logback is the default one for logs in spring boot coz it is light wait performance and it integrates well with the spring.
We have 2 mode like log4j2, java util logging
Log4J :
Kibana :

How u debug any defect by looking logs?
In application.property file we have to set the log level to debug(gives logs at debug level) then we have error, debug, info, etc
Different logging levels?
1.Trace
2.Debug
3.Info
4.Warn
5.Error
6.and Fatal

How u visualise the logs?
tools like - graphana

Status code?
200 -> success
404 -> not found
500 ->
Client error

Spring Profiles?
•	You can use the @Profile annotation to conditionally create Spring beans or entire @Configuration classes based on whether a specific profile is active. This means certain components or features can be enabled or disabled depending on the environment.
•	Spring Boot supports profile-specific application property files. For example, application-dev.properties or application-prod.properties
•	Profiles can be activated in several ways:
a. application.properties: Set the spring.profiles.active property (e.g., spring.profiles.active=dev).



Authentication in ur project? What details are present in JWT tokens?
Bearer token has issue and expiry time, subject, user email id and password.

How 2 microservices communicate with each other?
Microservices communicate using two main patterns: synchronous communication (like HTTP/REST APIs or gRPC) where one service waits for a direct response, and asynchronous communication (using message brokers such as Kafka or RabbitMQ) where services send messages and continue processing without waiting for a reply. The choice between these methods depends on whether a real-time response is needed or if decoupling and event-driven responses are more appropriate.  

caching(escache, reddish, haaslecast) =  @cacheable, @cachboot, @cachevict

Types of Caching?
2 types 
	1.In Memory
	2.Distributed

Annotations in Cache?
@EnableCaching - to enable cache/caching in ur application
@Cacheable - to cache data
@CachePut - to update cache data
@CacheEvict - to delete chahce data from cache

configuration class for bean; or application.prop/YML for data source; or for server/maven we have pom.xml file => used for customization of annotation

scope => 
	1. singleton(default scope( single instatnce for entire spring container)), 
	2. prototype(new instance of bean is created as per request), 
	3. request(whatever bean is created during request is available till the request lifecycle of request), 
	4. session(it is available untill the session expires), 
	5. websocket(its for websocket session)

custom scope ?

@springbootapplication -> covers 3 annotation(@configuration,@enableautoconfiguration,@componentscan)
@enableautoconfiguration -> automatically configure spring beans based on class path dependencies to load them in container

service registory -> 
	it's a database in microservices that  holds the location of all services instances(services to register by providing ip over there and discover by itself without hardcoding); if service instance crash/shutdown then its automatically removed from the registory.

service discovery -> 
Service discovery is the technology and process for automatically finding and connecting services and devices on a network, typically in cloud-based microservices architectures, eliminating the need for manual configuration

Microservices design pattern?
1.Eventual/consistency
2. SAGA
3. API Gateway Pattern
4. Circuit Breaker Pattern
5. Strangler Pattern
6. Command Query Responsibility Segregation (CQRS)
7. Event Sourcing
8. Sidecar Pattern
9. Backends for Frontends (BFF) Pattern

How SAGA pattern works?


SAGA design pattern in microservices -> 
	sequence of local transaction in multiple services, each transaction updates the state within its service; 
	if  any step fails then compenseting transaction is executed to undo the previous step.
{SAGA types ->1. coreography 2. orchestation(centrally managed)}
The SAGA pattern breaks down a complex transaction into a series of smaller, isolated operations, each handled by a different service.
Distributed transaction is a system that handles a small part of the work, but they all must complete their respective tasks successfully for the overall transaction to be considered successful.
SAGA coreography(decision logic is decentralised/asynchronous queue) ->(Event driven architecture) Services communicate directly by publishing and consuming events without a central coordinator. 
			It is mostly used as it is loosely coupled, event driven, services are flexible or independent, robust, cast and debug is easy. more preferred way.
			Observability and tracking of decoupled services/system is difficult.
SAGA orchestation(decision logic is centralized) -> A centralized orchestrator (a dedicated service) manages the entire saga, dictating the order of operations and instructing each participant service on what to do. 
			For synchronous communication(squence is required) we can use orchestration.

Idempotency -> 
	multiple times we do get, put, delete it doesn't create problem(means these are idompotent) but for post multiple entries are created in database.
	An operation is idempotent if performing it multiple times has the same effect as performing it once. In other words no matter how many times you call it, the state of the system remains the same.
	Commonly used in REST APIs and HTTP methods but also in general Java methods.
	Eg - GET, PUT, DELETE.(POST is not idempotent)
	A method is idempotent if calling it multiple times with the same parameters doesn't change the result beyond the first call. eg setting balance method in account class. (increment() method is not idempotent)

object class is the super class of all java classes and its present in java.lang package; methods -> equals, hashcode, clone, noify, notifyall, tostring, wait

OOPS concept -> 
	inheritance, polymorphism, encapsulaion, abstraction

a single class 'Employee' behind the scene follows inheritance as by default, object class is the implementation class; also it follows polymorphism(overloading and overriding(hashcode, equals))

Explain inheritance?
Inheriting the property of parent into child class.
We can extend class into class(as method definition is present) but we can implement the interface into class as interface has only property

Explain Polymorphism?
compile time polymorphism - it checks what type of object variable is. It is achieved by method overloading
run time polymorphism - it checks what kind of value is assigned inside that variable. It is achieved by method overriding.

How encapsulation improve code maintainability?
encapsulation ensures security also we can create an object of the class and get the attributes.

Can you achieve abstraction without abstract classes or interface?
Yes, by using private variabes(Method hiding).


ArrayList -> 
	frequently data access is needed; uses dynamic array
LinkedList -> 
	frequently insertion/deletion(modify) at middle or anyplace ; it's doubly linkedlist benefit

hashmap -> 
	not thread safe, allows null keys and null values, performance is faster then chashmap
	Average time complexity of get and put operations in HashMap is O(1).
	
concurrent hashmap -> 
	thread safe, not allows null key and null values, performance is slow then hashmap

remove duplicate from list and preserve its order -> 1. arraylist(items) 2. iterator(arraylist(set.add.arraylist(items)));[linkedhashset(items)]

if we need a thread safe map where reads are far more frequent then writes then which implementation you would choose and y?
I'll prefer concurrentHashMap coz its thread safe and two operations cannot be done simultaniously coz of concurrenmodificationException.
because they use fine-grained locking to allow multiple threads to operate on different segments of the map simultaneously, drastically improving read performance compared to coarse-grained synchronized maps. This contrasts with synchronized maps, which lock the entire map for any operation, creating bottlenecks and poor performance for high-read scenarios. 


Can two unqual objects have a same hashcode?
Yes, we call this situation as hash collision.
Hashcode do not guarantee uniqueness.


Can two equal objects have a different hashcode?
No, two objects that are considered "equal" according to their equals() method must have the same hashCode(). This is a fundamental contract for how hashCode() and equals() should be implemented, 
Failure to adhere to this contract can lead to unexpected and incorrect behavior in your programs.

suppose u are writing a code where u have to update score of players regularly then which collection u will use?
HashMap - for overall look up(fast lookup)
TreeMap - for priority queue(maintains ordering to get top and efficiently)


Is HashMap is synchronised?
No HashMap is not synchronized.

How to maintain insertion order in set?
I’ll use linked HashSet coz it maintains insertion order.

Difference between HashMap, LinkedHashMap and TreeMap?
HashMap : (k-v pair, array of bucket) It stores elements in no particular order but offers the fastest performance (O(1) in ideal cases) and allows one null key
LinkedHashMap :(linkedlist) It maintains the order of insertion using a doubly-linked list on top of a hash table, offering O(1) performance but slightly slower than HashMap
TreeMap : (Treeset) It stores elements in a sorted order (ascending) based on keys, using a red-black tree for its structure, resulting in O(logN) performance and disallowing null keys. 


If we want to synchronised HashMap then how can i achieve that?
We can use concurrentHashMap OR.
We can use Collections method i.e collections.synchronisedMap() which wraps the HashMap and provides synchronised access of it.

In which scenario I should go for concurrentHashMap and in which scenario I should go for collections.synchronisedHashMap()?
ConcurrentHashMap has high concurrency level so it supports multiple concurrent read writes operations so in that case we should go with the ConcurrentHashMap. so basically whenever the read write happens so that happens on a single bucket and rest of the buckets are free so we can use concurrentHashMap in this case.
Whenever we are going to use collections.synchronisedHashMap() so in that case it blocks the whole HashMap itself so the concurrency will be low in this case. 
So performance will be much better in case of ConcurrentHashMap coz we make lock on just a specific block so it will be much faster but synchronisedHashMap will be low.

What is concurrentHashMap?
ConcurrentHashMap in Java is a thread-safe implementation of the Map interface, designed for use in multi-threaded environments where multiple threads need to concurrently access and modify the map. It offers significant advantages over Collections.synchronizedMap(new HashMap()) or HashTable by providing better concurrency and performance.
To avoid ambiguity in ConcurrentHashMap null is not allowed as a key or value. 
It uses internal segmentation in a lock; concurrent reads and updates without blocking the whole map.


What is SynchronisedHashMap?
"synchronized HashMap" refers to a standard HashMap that has been made thread-safe by wrapping it with synchronization mechanisms. This is typically achieved using the Collections.synchronizedMap() method.
In synchronised map entire map is locked for each operations and performance is lower in multi threaded environment.


In HashMap suppose we want to print all of the keys in one go then how we can do that?
We can go with enhanced for loop and we can just say map.keysets and then we can just print all of them
Also we can say map.keyset.foreach and then we can pass each key as a parameter of lambda expression and we can simply print it out using java 8.


How hashmap works.
3 steps:
1.use hash function to get the hashcode
2.initialise the bucket, means it will have formula of hashcode mode arraysize, we will get the reference number
3.storing in the bucket, whatever hashcode key is found that key we will store it there.


what happens if 2 different key have same hashcode-
hashcollision will occur and hashmap store these key in same bucket.
before java 8 all entries in same buckets were stored in linked list
after java 8 all entries are stored in a Balanced Tree in a more efficient manner.


Suppose u r storing user session data in a hashmap, how you will maintain thread safety-
we can use synchronisemap
or we can use concurrent hashmap


Difference between HashMap and TreeMap?
Treemap : We usually used whenever we want to sort the elements by keys so it can be done either through natural sorting order or through custom comparator. RedBlackTree underline datastructure is used. Not thread safe. It does not allow null key but can have null values.
HashMap : It does not order the elements. So the keys are stored in random oreder. HashTable underline datastructure is used. Not thread safe. It allows 1 null key and can have multiple null values.

why Treemap not allow null key but allow null values?
Coz of sorting as Treemap sorts the keys using comparable or may use custom comaparator. So if we insert null key then treemap will use null key and that null key will be used for comparison so it will give nullpointer exception. And values are not going to be compared.

Suppose we have same method name and one is having object parameter and other is having String parameter and through main method we are passing NULL the which method will be called and Y?
String method null will be called coz java chooses most specific methods so when we have to resolve the overloaded methods calls so both can accept null, String and object both accepts null but string is more specific then object coz string is the subclass of the object so string will be called.

What if both methods are equally specific like Suppose we have same method name and one is having int parameter and other is having double parameter and through main method we are passing NULL the which method will be called and Y?
If both methods are equally specific then we will get compile time error.


What if both methods are equally specific like Suppose we have same method name and one is having int parameter and other is having Integer parameter and through main method we are passing NULL the which method will be called and Y?
Integer will be called coz it is wrapper class.
And null is a valid value for an Integer object (a reference type), but it cannot be directly assigned or passed to a primitive int type. If you attempt to pass null to a method expecting an int, it will result in a NullPointerException at runtime 


vector -> 
	introduced in java version 1.2, it's synchronized, it came before arraylist, it's threadsafe, it's less efficient, less methods present, allows 1 null value and 1 null key

volatile keyword -> 
	value of a variable will be modified by different threads, used in multithreading env. ,it ensures value visibility across the thread, Problem -> it doesn't provide automicity of read and write operation, it shows most recent value, to maintain automicity we need to use "automic" keyword.
	Volatile ensures that the changes to a variable are immediately visibles to all threads in multiThreading.

Executor service ->
	It is a class that helps in maintaining a pool of threads and assigning them tasks.
	It provides methods to submit tasks, manage the life cycle of threads, and get the results of tasks.
	It is a convenient way to execute tasks in parallel and manage the resources efficiently.
	The ExecutorService is a powerful interface in Java's java. util. concurrent package that simplifies managing tasks that need to run concurrently. It abstracts away the complexities of thread creation, management, and scheduling, allowing us to focus on the actual work that needs to be done.
ExecutorService Creation Methods:
	1.Executors.newFixedThreadPool(3): creates an ExecutorService with a pool of 3 threads.
	2.newCachedThreadPool(): Creates a thread pool that adjusts its size dynamically based on the workload. Idle threads may be terminated after a certain period.
	3.newSingleThreadExecutor(): Creates an ExecutorService that uses a single worker thread to execute tasks sequentially.
	4.newScheduledThreadPool(int corePoolSize): Creates an ExecutorService that can schedule commands to run after a given delay, or to execute periodically.
	
	
Transient -> 
	field should not be serialized.

String ->
	immutable, once created it cannot be modified, thread-safe(synchronised)	

String buffer -> 
	mutable, synchronized, thread safe(Used for multithreaded environment)
	
Sring builder -> 
	mutable, not synchronized, not thread safe(Used for single threaded environment)

Why String is immuatble and what are the advantages of being immutable?
String is immutable for the security purpose.


when we can use String buffer, give a scenario?
	As String buffer is thread safe and we use it mostly in multi threaded environment.
	Suppose we have a web server and that is handling multiple request simultaneously. And suppose we are writing the logs for each request so in this case its better to use String buffer instead of String builder.
	Coz if multiple thread call log method so in that case string buffer which is synchronised so that prevents the data like being generating the inconsistent result. so there will be no inconsistent result and logs will be printed one after the another.
	Coz at a time only 1 thread can come but if we use string builder then in that case it might corrupt the data and it might not be useful.

	
How does java ensures Thread Safety?
	1.Synchronised keyword or Synchronised block can be used.
	2.Volatile keyword is there using this visibility of variable can be done across all the threads.
	3.Concurrent collection is there like concurrentHashMap, CopyOnWriteArrayList.
	4.Atomic can be used.
	5.Using Thread Safe classes like String buffer, Vector, HashTable.
	
Suppose we have a string then how to remove spaces from this?
We can use replaceAll(). then we pass " "(want to replace) to replace with empty().
OR by using trim() method as -> originalString.trim() OR originalString.strip() OR originalString.replaceAll("\\s", "") OR
using java8?
	String.char().filter(n -> !character.isWhiteSpace()).collect(Collectors.toList());
	OR =>  String s = "    Geeks     for Geeks     ";
	    String a = s.chars()
        .filter(c -> !Character.isWhitespace(c))
        .mapToObj(c -> String.valueOf((char) c))
        .collect(Collectors.joining());


Difference between fail fast and fail safe iterator?
fail fast and fail safe both are iterator.
A fail-fast iterator operates directly on the original collection, throws a ConcurrentModificationException if the collection is modified during iteration, and supports iterator methods like remove(), ensuring data integrity but not allowing concurrent changes. (Use Case) Ideal for single-threaded applications or when you need to be immediately notified of any structural changes. (Eg) Iterators from java.util collections like ArrayList, HashMap, etc.. 

A fail-safe iterator works on a copy or snapshot of the collection, does not throw an exception on structural modification, and typically does not support iterator methods like remove(), prioritizing stable iteration over data accuracy. (USe case) Best for multi-threaded applications where concurrent modifications are expected, ensuring stable iteration without exceptions. (Eg) Iterators from java.util.concurrent collections like ConcurrentHashMap, CopyOnWriteArrayList. 
	


= =  -> 
	compares two object/references and check whether they point to same memory location
		
.equals -> 
	compares only values/content
	
For eg :
String a =  new String("XYZ");
String b =  new String("XYZ");

a == b => False coz memory refernce is different
a.equals().b => True coz content is same.

What is serialVersionUID?
Mostly we use this inside the bean classes.
We use it while serialization and deserialization. so this is kind of unique identifier and it is static and final so that we declare there.
So main purpose of this is to serialize an object and whenever that is going to be deserialized then it should just mix urs that it is the same object class which was serialized.
So if a class definition changes suppose any fields are being added or removed or any methods are getting modified then in that case serialVersionUID also should be changed. So coz of this it helps that an object serialized with an older version of the class is not serialized with the newer version and that might not be compatible also. So just to track all this thing we use serialVersionUID.

difference between Serialization and Deserialization ->
Serialization -> It's a process of converting an object into a format that can be stored or transmitted such as byte stream.
And these byte sream can then be save into a file or it can be send over a network or store in a database.
Basically its about the objects state making it portable so whenever we want to port the object so we use serialization process
An ObjectOutputStream is used to write the object to an output stream (e.g., FileOutputStream for files). The writeObject() method of ObjectOutputStream performs the serialization.
for eg -> storing a java objects state into a file

Deserialization -> It's opposite of serialization
If we want to retrieve the serialized object then we have to deserialised it first(byte stream is converted back into a Java object.) then we can read that object in same state
The readObject() method of ObjectInputStream reads the byte stream and reconstructs the object. The returned object needs to be cast to its original type.


What annotation/liberaries we use for serialization and deserialization?
we can use serializable interface for serialization
we have libraries like jackson, gson that can handle the readable formats of data.


what challenge u have faced during serialization and deserialization?
yes 
Versioning - if the class structure changes like adding or removing fields can cause compatibility issue during deserialization like invalid class exception so to handle this we use "serialVersionUID" field in java
Performance - serialization might be slow when dealing with large files or complex data payload so to optimise this we can use llibraries like Kryo, etc
Security - Deserializing data from an untrusted source can lead to some vulnerability like RemoteCodeExecution so to address this we should validate the data source and use techniques like object whitelisting to ensure only expected class are dserialised.



Difference between pass by value and pass by reference?
Pass by Value - 
	Java is consistently a "pass by value" language
	When a variable is passed to a method, a copy of its value is passed so the method works on this copy so any changes made inside the method don't affect the original variable.
	In java mostily all primitive are passed by value.
	eg - inside method we reassign value as : value = 20;
Pass by Reference -  
	Java does not support "pass by reference" in the traditional sense
	In java objects are passed as an argument still uses pass by value
		eg -  builder = new StringBuilder("New Value");


Difference between arraylist and linked list?
arraylist and linked list both are implementation of list interface in java
but the storage mechanism for both are different-
ArrayList uses dynamic array list to store the element so when we add an elements beyond its current capacity so it basically resizes the array by creating a new one with the larger capacity and copying the elements over it
In Linkedlist uses doubly linkedlist so where each elements contains reference to the previous and next node.
So if our applicaion involves frequent random access or searching then in this case we can use arraylist
And if frequent insertion and deletion is involved in the middle or bigining of the list then we can use linkedlist coz it has the links between the nodes
arraylist is more memory efficient coz it only stores the data and some extra space for resizing, linkedlist uses more memory as each node has two additional references - 1 for the previous node and other for the next node.


Difference between comparator and comparable?
Both are used for sorting purpose and are functional interfaces
comparable - 
		used when we want to define the naural ordering of object, eg: sorting string Alphabetically or numbers numerically but since the comparison logic is part of class itself so u can only have 1 sorting strategy for the class eg: sort with only 1 property of an employee.
		It has a method called compareTo() which we overwrite and write the sorting logic for that
comparator - 
		We can use multiple sorting logic. eg we can use any of the property for the sorting.
		It has a method called compare() so that is the place where we write the logic of comparison


In which package comparator and comparable are found?
comparable - java.lang
comparator - java.util

what is Annonymous class?
An anonymous class is a class without a name that is defined and instantiated in a single expression. It is a type of inner class used when a specific, one-time implementation of an interface or an abstract class is required, or when overriding a method of an existing class for a single instance. 
Eg ->
interface Greeting {
    void sayHello();
}

public class Main {
    public static void main(String[] args) {
        // Anonymous class implementing the Greeting interface
        Greeting englishGreeting = new Greeting() {
            @Override
            public void sayHello() {
                System.out.println("Hello!");
            }
        };

        englishGreeting.sayHello(); // Output: Hello!
    }
}



with comparator what changes u see in Java 8?
In java 8 we have removed boiler plate code.
Like instead of creating a separate class or using an annonymous (inner) class we can directly write the sorting logic as a lambda eg: employe.sort(pass parameter in lambda expression).compareTo().
Java 8 introduce the Comparator.comparing() method which allows us to create comparators in a cleaner way.
We can easily reverse the sorting order by using reverse() method of java 8
[We can directly use stream.sorted() method of java 8 to sort the elements]

Is java 100% object oriented?
No java is not 100% object oriented but it is 99% object oriented coz we have primitive datatypes like int, float, etc.
so int, float are of primitive datatype which cannot be converted into object however we have wrapper classes like Integer


why we have not made java 100% object oriented is there any benefit?
Benefits are there for eg: whenevr we are applying sorting and all directly in the memory so it happens fatser way without overhead of object metadata
So operations on primitive are faster coz they avoid overhead of method calls and object differentiating
using primitive makes the syntax simple and very readable for basic arithmetic or logical operations and control strucures eg: int x= 5; so its much more simple without creating a object
it's much faster as compared to wrapper classes
primitive contains less memory then wrapper class
primitive data type does not impact garbage collector

How This keyword differs in inside a annonymous inner class and lambda expression?
	Inside lambda this refers to the enclosing class instance 

what is Heap dump?
It's a snapshot of heap memory of jvm at specific point in time so it contains information about all the objects in thier memory, their types, references and data
So this is very much useful for debugging and analysing memory related issues so any kind of memory leaks happens so this is used to prevent that.
So it identifies which 
enable that we can use heap time generation
using tools we can analyse like how and which object is 



create indexes in SQL -> 
	it's a db object helps in retrieving records very quickly and more efficiently, 
	indexing is applied to column on both table and views(declare a column as an index within a  table/view); 
	Query eg => create index index_name ON table_name column_name

indexing working internally -> 
	as query runs we can see in table index is generated , some data strucure/algorithm like B tree, hash table is used; based on algo used it scannes only few rows of tables

Common types of indexes include:
•	Clustered Index: 
Determines the physical order of data rows in the table. A table can only have one clustered index.
•	Non-Clustered Index: 
A separate structure that contains the indexed column values and pointers to the actual data rows. A table can have multiple non-clustered indexes.
•	Unique Index: 
Ensures that all values in the indexed column(s) are unique.
•	Filtered Index: 
Applies an index only to a subset of rows in a table, based on a specified filter condition.

Pagination in SQL-
	The main concept of the Paginating results in SQL involves the use of the 'LIMIT' and 'OFFSET' clauses in SQL queries. By the name of the clause, we can know that it simply limits the number of rows.
The 'LIMIT' clause is mainly used for restricting the number of rows that are returned in a set of results. Here the 'OFFSET' clause is to specify the starting point within the result set.

				
Rest API and SOAP?
Rest API : We basically write request body in xml format and pass it to the backend
SOAP : 	
Feature					SOAP									REST
Type					Protocol							Architectural Style
Message Format			XML									JSON, XML, HTML, Plain Text
Transport				HTTP, SMTP, TCP, etc.				Primarily HTTP
Statefulness			Can be stateful						Stateless
Security				Built-in (WS-Security)				External (HTTPS, OAuth, JWT)
Complexity				Higher								Lower
Use Cases		Enterprise, high security, reliability		Web/mobile, microservices, public APIs

			
							SET 2

Java 8 :
- We have interface A and interface B both have Same default method;
A class implement both interfaces.
We want to print value which is in default(common) method?
Diamond problem -> compiler will throw compile time error and will ask forcefully override method and in that method say which interface method we want to call like interfaceA.super().method_name(); 

We have interface A and interface B both have Same default method, class C is implementing both interfaces;
We will get compiler error if class C does not override. else class can call A.super().m() or B.super.m().

We have interface A  has abstract m() and interface B have default method m(), class C is implementing both interfaces;
Default will be called here if we don't override anything.
Also class can override but not mandatory, object call uses default method.

We have interface A and interface B both have Same abstract method m(), class C is implementing both interfaces;
class C must implement method m().

We have interface A has static m() and interface B have default method m(), class C is implementing both interfaces;
Here default is inherited, but static is not inherited.
We can call via C class object so default will be called. Also we can call via interface of static as static(A.m());

We have interface A and interface B both have Same static method, interface C is implementing both interfaces;
It is not inheritted by class.
C class must call using interface name as A.m() or B.m()

We have interface A has abstract m() and interface B have static method m(), class C is implementing both interfaces;
class C must implement abstract; static is ignored by instance.
class C object calls class method, we can call static method interface by A.m();

We have interface A has abstract m() and interface B have abstract method m(), and interface C have default method m() class D is implementing both interfaces;
Default can be inherited if no conflict; class must resolve abstract.
Compiler forces class D to implement abstract; default is optional.

{
1. Default - ready to use (inherited by class)
2. Abstract - promise(class must implement, also default wins)
3. Static - not inherited, call with interface name.

Can we override and overload the static methods?
In Java we can overload static method but we cannot override them. Coz static is something related to the class so just with the class.static method we can access it.

-private method in java interface?
support mostly logic of static and default method in java8.
private method came in java9
If logic is bigger in static/default then we want to separate/private the logic then we use private method in interface and that is not accessible outside interface and only that interface methods can use it so we use private method for code reusability within interface, more readable, maintainable, avoid duplication in logics

Can we overide Private and Static method?
Private method cannot be overridden coz it is not visible outside of the class.
Static methods also cannot be truley overriden coz they belong to the class not to the object but if we define a static method with the same name in child class then we say it method hiding not overidding, so it looks like overriding but it is not.

default method? -> 
	backward compatibility for older code, And don't want implementing classes to override default method as they can overrirde or can enhance the logic
	
static method? -> 
	class which are implementing static interface that cannot be overriden by implemening classess; we can call this static method by interface_name.method_name

variable argument -> 
	method to accept any number of parameter of same type then we use variable argument
	
syntax -> parameter type ...; 

psvm(String[]) -> here can we replace string array parameter in main method with variable argument.?
Yes we can replace but this is not recomended way to use

class Test {
static method()
test a = null;
a.method()
} output = ?  yes it will working

equals and hashcode contract?
These both are deployed in object class
It is a fundamental principle for how objects behave in hash-based collections like HashMap, HashSet, and Hashtable.
so whenever we override equals then we should override hashcode as well from object class coz If you override equals() but not hashCode(): Two objects that you deem "equal" by your custom equals() method might still have different default hashCode() values (which are typically based on memory address). This means they could be stored in different buckets in a hash-based collection.
In essence, overriding hashCode() ensures that logically equal objects will hash to the same bucket, allowing hash-based collections to function correctly and efficiently.



suppose class B extends class A and both have constructors then in main method we are creating object of B then whose constructor will be called first?
Parent class constructor will be called first then the child class constructor so class A constructor will be called.

What happens If parent class do not have default constructor but have only parameterise constructor?
If parent has parametarised constructor then child must explicitly has to call parent class constructor using the super keyword otherwise compilation will be failed.
In method overloading if we change the method return type then we get compile time error.
We cannot override static method as static method belongs to class, not to any individual object
Can we call both super and this in the same constructor?
No, coz both must be the  1st  statement in the constructor so u can only use one of them.

What happens internally when u create an object in java?
When we create an object we get the reference in heap memory which is used for storing purpose, means object is created in heap memory and we get the storage.
When we create an object the class is loaded first in JVM.
Memory is assigned in the heap memory.
Default initialisation, constructor call will be there.

Can constructors be overridden in java?
we can have multiple constructor(overloading).
No, constructor cannot be overridden coz they are not inherited by child classes.
So constructors are meant to initialised object of their own class if they allow overriding it would break the object creation chains since child constructors are not supposed to redefine parent constructor.
What will happen if u call a method inside its own body without a terminating condition?
It will be a infinite loop coz we don’t have a termination. Since it is a infinite recursion it will lead to stackoverflow.

How recursion is different from iteration?
Iteration : We have  1 loop like for, while, do while.
Recursion : Here the method calls itself like we have method add() and inside its body it is calling itself.

Explain different types of class loaders in Java?
We have 3 types of loaders :
1.Application Loader -> It  is responsible for loading application-specific classes from the classpath.
2.Extension Loader -> It loads classes from the JRE
3.Bootstrap loader -> It is core part of JVM loads

JVM Architecture:
	The Java Virtual Machine (JVM) architecture provides a runtime environment for executing Java bytecode. It can be understood through its three main components: the Class Loader Subsystem, the Runtime Data Area, and the Execution Engine. 
1.	Class Loader Subsystem: a.bootstrap, b.application, .extention
2.	Linking and Initialization : 
a.	Verification: Ensures the loaded bytecode is valid and secure.
b.	Preparation: Allocates memory for static variables and initializes them to default values.
c.	Resolution: Replaces symbolic references with direct references.

Initialization is the final phase of the class-loading process. Static variables are assigned original values and static blocks are executed.
3.	Runtime Data Areas: 
a.	Method Area:
b.	Heap:
c.	JVM Stacks:
d.	PC Registers: 
e.	Native Method Stacks:
4.Execution Engine:
		a.Interpreter: 
		b. Just-In-Time (JIT) Compiler:
		c. Garbage Collector:
5.Java Native Interface (JNI)



Difference between loading and linking?
Loading : when we create an object it gets loaded, i.e loading
Linking : The class is prepared for execution so actually there are 3 steps-
1.Verification
2.Preparation
3. Resolution

Difference between JDK, JRE and JVM?
JDK -> It consist of JVM and JRE.
JRE -> It actually executes the program. It convert programs to byte code like .class
JVM -> It has JRE, and application libraries as well. Which is needed to execute the program.

What’s the role of JIT?
JIT is present in JRE. It converts the .java class to byte class i.e .class so that we can run it anywhere.(Platform independent)

Despite there is garbage collector in java y we might see the memory leaks?
Sometimes the objects are not in use but it still points/refers to some point like null object so it leads to memory leak.

only overriding equals is not enough - explain
hashcode of object class is generated behind the scene and is used for comparison; which can have same/different values/objects so it fails to compare the equals values

base class & abstract class?
create objects, have methods, can be inherited, may or may not be extended by other class
abstract class cannot be instentiated directly, may contain or not contain abstract method

marker interface?
kind of empty interface - it does not have any methods, its kind of marking/tagging a class eg - serlizable(convert class object to byte stream), clonnable(alowed to clone but if cloneable is not implemented then thorws clone not supported exception)

custom marker interface- how to create?
define empty interface(marker interface) then have 1 class which will implement marker interface then 1 class to check if a class is implementing marker interface.

What is functional interface?
functional interface are those interface that contains only one abstract method.
OR A functional interface can have multiple default or static methods with implementations, it is the presence of exactly one abstract method that defines it as functional. 
eg - Comparator, comparable, runnable, Callable are functional interface


can we write functional interface without abstract method?
No, coz @functional interface must have exactly 1 abstract method, coz this method only use lambda expression and method reference

Explain Functional interface with real life example(Predicate, funcion, consumer)?
	4 types of functional interface is there -
		1. Predicate - It is checked based on boolean expression. It accepts a single argument and returns a boolean result.	
		2. Consumer / Bi-Consumer - It is used to accept input, it won't give output. It accepts a single argument and returns a boolean result.
		3. Supplier - It only gives the output, without taking input like random otp generation. It does not take any arguments but provides a result.
		4. Function - Input and OutPut. It accepts a single argument and returns a result.
Built-In Java Functional Interfaces :
Comparator, comparable, lambda	 expression, runnable, Callable are functional interface

	
What problem option class resolve in Java 8?
It is used to avoid nullpointer exception.
It has so many inbuilt methods - like isempty(), isPresent(), .orElseThrow() ... , etc are there to check or avoid nullpointer exception

Difference between map and flatmap?
Map - it returns a stream ; it is one-to-one mapping ;
FlatMap - it returns a stream of streams ; it is one-to-many mapping ;

Why do we usually avoid many to many direct mapping in large enterprise projects/applications?
its not a good practice coz there are multiple large amount of data


In which scenario you would prefer flatmap?
extracting words from a list of sentences.
It is used for flatening as well as transferring the element.

How Java Time API is better then old Date Calender APIs?
In java 8 Date API came before this we have to parse it.
So, after java 8 no need to parse means directly we can use date.of(), date.now()
It's immutable, thread safe.


If a class contain date the how you will maintain immutability?
I'll create a new DateOf new Date and will use date.getTime

What is ENUM?
ENUM represents the fixed set os constants like we have Weekdays - monday,tuesday, wednesday... so those things if we want to use in our code then we can use ENUM. So those fix constants we can give in code.

Advantages of ENUM over Constants?
ENUM is used for predefined constants, ENUM can be written in a class or in a separate file as well.
That means when we want to define self constants(Like weekends which will be used in switch case) then we use enums.


Can Enums implement interfaces?
Yes as ENUM cannot extend classes but yes it can implement interfaces


Can we use RequestParam and Pathparam in same method?
Yes


Can we use 2 same url calling from different requestMapping?
Yes


Difference between Valid and Validated?
valid - @Valid is part of the standard Java Bean Validation API (JSR-303/JSR-380). This makes it a standard, portable solution for validation across different Java EE environments.
Validated -  @Validated is a Spring Framework-specific annotation. It extends the functionality provided by @Valid.


Can we have multiple @ControllerAdvice? Yes by using base package -> eg: @ControllerAdvice(annotations = RestController.class, basePackages = "com.example.admin.controllers")
ControllerAdvice is mainly used to handle global exception
We can write only one controllerAdvice and multiple exception handlers.
@ExceptionHandler is used to handle the local exceptions


Difference between returning ResponseEntity and returning an Object/String through RestAPIs?
ResponseEntity - it becomes generic return type like we write it for ? as we don't know what will this method will return so we use ResponseEntity.
We can send HTTPSTATUSCode, we can send headers as well in response entity.
Object/String - 


What is/does BindingResult?
BindingResult provides a centralized and standardized way to capture and manage both data binding and validation outcomes, enabling robust error handling and a better user experience in Spring Boot applications.

	
Internal working of @AutoWired?

Git rebase?
used to integrate changes from one branch into another by moving or combining a sequence of commits to a new base commit. It essentially rewrites the commit history of a branch to make it appear as if the work started from a different, often more recent, point. 
Git cherraypick?
When we want to cherry pick from particular branch then we use cherry pick.
It allows you to select a specific commit from one branch and apply its changes to another branch as a new commit. This is useful when you need to incorporate a particular change without merging the entire source branch. 

Treeset having 2 below values
1	adding null, 
2  adding object abc
Now print output?
runtime exception -> coz we added null as null values are not allowed in treeset.
coz it uses comparator internally and which has compareto() method so null compare to any object will throw nullpointer exception at runtime.

finally block will not execute if we write return statement as "system.exit()" at either in try or catch block.

different components of microservices?
service discovery -> Eureka server used to discover services for communication among the microservices.
API gateway -> act as a front door for all API's
user service -> used to handle data related to user
setting service -> used to handle all settings related to project.
histurix dashboard -> used to display information about faults in ur application.
ELK stack -> used to showcase the logs in ur application like we use elastic search.
Elastic search -> used to log the information about ur logs or application details
Logs stack -> ued to index the logs to elastic search
Kibana dashboard -> used as a console where we can see the information about our logs
load balancer
service registory
AOP
circuit brakers
Explanation- As soon as any request is made it goes to API gateway there the load balancer will be there which will root all the request to different instances of microservices,  so through API gateway it goes to service discovery(eureka) and it roots the traffic to different instances, url of this instances is dynamically generated

circuit braker pattern?
its used in microservice communication. if any microservice is down and is not able to communicate with other microservice so in this case circuit is broken so we use historic and using historic we write fallback method for microservices which is down to give service/reponse to other microservices
The Circuit Breaker pattern typically operates in three main states: 
	i.Closed (Happy): In this state it operates normally, allowing requests to flow through between services.
	ii.Open(Failure) : 
			When the monitored metrics breach predetermined thresholds, signaling potential issues with the downstream service, the circuit breaker transitions to the Open state.
			In the Open state, the circuit breaker immediately stops forwarding requests to the failing service, effectively isolating it.
			This helps prevent cascading failures and maintains system stability by ensuring that clients receive timely feedback, even when services encounter issues.
	iii.Half-Open(Check if service is recovered): 
			After a specified timeout period in the Open state, transitions to Half-Open state.
			Allows a limited number of trial requests to pass through to the downstream service.
			Monitors responses to determine service recovery.
			If trial requests succeed, indicating service recovery, transitions back to Closed state.
			If trial requests fail, service issues persist.
			May transition back to Open state or remain in Half-Open state for further evaluation.


How u handle fault tolerance in ur microservice architecture(Circuit breaker)?
Circuit breaker pattern can be used to handle the fault tolerance
Consider there are two services and one service is calling to other end and other is calling to 3rd service (A, B, C)
consider 3 services - A is calling to B and B is calling to C but in case C is not responding so in that case we can use circuit breaker pattern to handle a failure of service A so 
we can implement a retry mechanism where if the service is down and u r trying to call that service but u r not getting response so u can try once, twice, third and then if that service is still not available then u can send a message that
this service is not available or u can configure the timeout settings.


There are 2 microservice - microservice 1, microservice 2 ; how do these microservice communicate with each other?
suppose u need some information from microservice 2 so to get info microservice 2 will call microservice 1 by using restTemplate.
So by using restTemplate.extend we can call the end point which is available in microservice like restTemplate can get the instance of restTemplate then
we can use instance.get() method which takes two parameters-(URl(end point), method type(get/post/put)) then we need RequestEntity(u r passing some request as part of Header or as a part of that request)
then u can build requestEntity by using that information
Then at the last you will get a response when u invoke that endpoint so that response is need to be captured somewhere or in some entity so that will be 4th parameter.
And using this u can give it to another microservice and get the information.

Can we do this communication in some other way like using some message broker?
yes we can use message broker for passing messages like we can use a queue or Apache Kafka where one microservice will produce the messages in that queue and the other microservice will consume that queue
So in this case -> one microservice will continuously produce the messages and the other microservice will continuously read/consume the messages
Also we have FinClient that can also be used to perform communication between microservices


interservice communication in microservice(how 2 microservice communicate with each other?) -> 
	1. sync(REst API (http(direct communication)), finclient (complex(multiple service intercommunication)), webclient(reactive programming(high concurrent application(share market data))) ) 
	2. async -> 1. message broker(rabbit mq, kafka)- calling method does not wait for response and it just move after creating/producing data ; and 2. messages and events


what is synchronous and asynchronous way of communication in microservices?
Synchrounous communication-
Synchronous communication means u r performing the operations sequentially, 1 transaction should be completed before proceding with another thransaction
Asynchronous communication- 
In asynchronous communication u can perform multiple transactions parallel so for this asynchronous communication we use Queues so one service will be producing the results and putting it into queue and the other service will read that queue continuously.

Flow of service discovery in ur project/Application?
Service Discovery is used to discover already services which are registered with that discovery server so in our application we are using Eureka server as a service discovery
So whenever there is a requst from UI or client the request goes through the API Gateway and then the
API Gateway identifies which service needs to be invoked so it needs to get the instance of that particular service so it can check the service discovery whether that instance is available or not and if that instance is available then 
you can use that instance and route that request to the particular instance of the backend service.
So basically 2 annotations are used to discover the services -
	@EnableEurekaServer - It is used over the class where ur service will act as a eureka server.
	@EnableEurekaClient - Used to make sure that this service act as a client and this service will be registered with ur eureka server and that eureka server url can be mentioned inside ur application.properties file so that it will register with that particular server
	

How u secure the microservices?
I have used JWT token for authentication and authorization.
(JWT) is divided into three parts: the Header, the Payload, and the Signature, which are Base64Url encoded and joined together with dots (.). The Header defines the token's type and the algorithm used for signing, while the Payload contains the actual information as "claims" about the user or entity. The Signature, created by hashing the encoded header and payload, ensures the token's integrity and authenticity.
	
which cloud provider u have used to deploy the microservices application?
It is taken care by our build and release team.
So we basically provide our applications jar file and they use that jar file and generate the docker images and by using those docker images they deploy the application.


fault isolation
its a designed principal in a distributed system and software architecture that focuses on limiting the impact of failures within a system. so this insures the failure in one component does not cause cascading failure in other parts of the system. the main goal of this is to contain the failure within the faulty component and prevent it from the malfunctioning of entire system.

different ways to create spring boot application
using spring boot initializer (spring.io) website here we go and add all objects of dependency and it will generate project for us then we import that for our ide --- best way
using ide - sts, intellige ide
using command line interface

spring boot actuator, its end points and its advantages-
Spring boot Actuator:
			Actuator is basically a built in configuration, we just have to add a dependency of it in pom.xmml
			Default end points of actuator are - health and info however we can change their behaviour.
			Actuator is used for the monitoring and managing of the application like we have health, matrix and all.
			So It basically provides the production ready features. And if we want to access it, then we can access it using like actuator/healh, actuator/infoMatrix, etc
it's a module that provids production ready features so that we can monitor the health and env checks, etc . it provides various end points like - info, health, matrix, etc which is used to check spring boot health applications

Depenency injection, how it works or bean lifecycle-
3 types – 
1.constructor(mostly used) injection : It supports immutability, easier for unit testing, it helps to avoid circular dependency.
2.setter injection : After the bean is created, Spring identifies the setter methods marked for injection (typically with @Autowired or configured in XML) and calls them, passing in the required dependency objects.
3.Field injection :  A field within a class is annotated with @Autowired (or a similar annotation).
It helps in bean lifecycle by decompiling your bean creation and configuration

Difference between autowire and manual bean wiring in xml configuration?
Autowire : we just use the annotation @autowire when we define the object then top of that we use @Autowire annotation.
Xml configuration : In earlier spring, not in spring boot we have to write the configuration in xml file i.e xml configuration.
Explain NoSuchBeanException?
Sometimes we try to create any bean which does not exist so at that time we get this exception.

Spring bean(entity class)-
@bean comes in @autowired of @configuration which is for entity class
To make code more optimize we use database beans to map columns to java objects(Spring boot applications)	


Database connection in spring boot-
Add dependency of mysql in pom.xml file then define datasource- username, password in application.property file

How you define any custom property in Spring boot?
In application.property or in .yml file we can define that property/key/message.
And that we want to use in java so we can write @value -> [@Value("${refCodeValidity}")] and can write $sign before that and we can use it and also we can use @configurationProperties
		eg done in our project => {
	@Configuration
	@ComponentScan(basePackages = "com.ibm.sbi.lotus.cloudant")
	@ImportResource(locations = { "file:/websphere/SharedLib/applicationContext.xml" })
	@PropertySource("file:/websphere/SharedLib/application_shared_uat.properties")
	@PropertySource("classpath:application.properties")
}


Difference between application.properties and application.yml file?
Both are used for external configuration so we can use either of them
application.properties : It uses traditional way like key value pair format.
application.yml : It uses yaml format, so it supports formats like nesting and readibility. suppose we want to give server.port and also we want to give server.servlet then we just see identation in yml file. 
server
	port : 8080
	Servlet : 12.0.6
So basically yaml file is more readable.


Singleton designpattern and database connection relation between them-
we have used singleton class implementation for database connection as we need it to connect database only once.
Singleton maintains once instance only.


@transactional -
If some process is hapening and due to some reason the process got corrupted or stopped then we have to rollback the process so for this we use @transactional
@transactional best way to used is at method level not at class level.
It is used when we perform some operation in database like if we are depositing money then we use @Transactional

@transactional -> what if we write @transactional at class as well as at method level?
- method level will override the class level annotation but it is not preferred coz it will not behave properly 
So it is preferred to use at method level coz at method level we will come to know the exact issue and it will be easy to track.
@transactional is used for the methods or the process which will be executed at once and while execution if issue occurs or it gets corrupted then it needs to be rolled back.

On remote service failing how you handle rollback transactional-
Compensation transaction/distributed transaction pattern like SAGA. so we could implement SAGA Pattern here.

Notification system-
text notification through ....

JAVA Email-
3rd party service we hhave used i.e web....

Deployment in web application-
We did using AWS -
clone repo > do code change > merge code > conflict resolve manually by using head and arrows > push code to pipeline > Pipeline deploys the code
Steps in pipeline -
build > create image >.....


How you deploy the Spring boot Application?(docker, AWS,...)?
First we write code(Spring boot microservices) and then we move that in docker image then that docker image is pushed to the ECR(Elastic Container Registory) that is basically AWS code build.
Then further once it is pushed to ECR then we use AWS code pipeline after that we run that ECS(Elastic Container Service) of AWS.
So all this docker and pushing to the Elastic Container Registory we write yaml file and using that yaml file we write all the steps need to be performed.
And all this things happens automatically.


How Springboot simplifies the web development -
.Used to reduce boiler plate code.
.Annotations make it easier like - autowired, springbootapplication, actuators(health maintain), swagger(byforget API), more easier to maintain a web application.

In Spring boot there are various ways to handle the incoming data request from http, so what are the various ways?
We have a controller then we write @RequestMapping, further we have at method level annotations like @GetMapping, @Postmapping, @Putmapping.

How to find employes?ID in spring boot?
We can use @RequestParam with whatever in question mark like id.
We can use @PathVariable for empyee/ID
We can use @RequestBody so it will be in JSON format so all that are coming in request can be converted into objects


Servers that springboot provides inbuilt-
tomcat(default), jetty, Undertow
We can exclude default server by excluding it from the pom.xml file.

Tools used for database migration -
flyway/liquibase
Springboot provides built in database migration tools like flyway/liquibase


Spring boot data jpa advantages over standard jpa -
It has methods like - .save, .findAll, .flash which helps to not to write quries(native quries).

Use spring data JPA, use variable search criteria by using dynamic query-
use @query and write where condition
We can use inbuilt query or custom query here as per requirement


when to use custom query-
when we have to update something based on some condition.


explain the concept of repository in Spring data JPA-
We have @Repository for database transactions.
We have different types of repository - JPA, CRUD, PagingAndSortingRepository
Based on requirement we can choose which repository we want.


Limitations of repository-?


If you have a long batch operation then how would you optimize transaction to manage performance and consistency-
We can use Cache - to enable cache(not call dal API everytime, save it in cache)
We can handle it using segments and call them using segment wise


What is dispacther Servlet?
It is kind of initial or central controller in Spring MVC framework.
It handles all the HTTP request and whatever the responses are there in the web application.
So basically it is a front controller in Spring MVC. So whenever a client sends the any request so first it goes the web.xml in Spring MVC but if its Spring boot then it autoconfigurs the dispatcher servlet.
And then further dispacther servlet finds the appropriate controller using the handler mapping and then it invokes the controller method and then it returns the model and view object.
And then it further goes to the view resolver so it resolves the view like -> JSP, JSON; And then the response is further rendered or send to the client.


Servlet dispatcher (How the request calls the particular Controller or how request is handled?
	DispatcherServlet is the Front Controller in a Spring web application. It acts as the entry point for all incoming HTTP requests.
HandlerAdapter interfaces configured in the Spring application to process the request. It uses annotations like @Controller, @RequestMapping, etc., to identify handler methods (controller endpoints) and prepares the appropriate response objects based on the controller's output.
	The Spring DispatcherServlet identifies which controller and method to call through a process involving HandlerMapping and annotations.
HandlerMapping: 
	When the Spring application starts, the DispatcherServlet initializes and detects all beans annotated with @Controller. It then uses HandlerMapping implementations (like RequestMappingHandlerMapping) to scan these controller classes and their methods.
Annotation-based Mapping: 
	The HandlerMapping primarily relies on annotations like @RequestMapping, @GetMapping, @PostMapping, etc., defined on controller classes and methods. These annotations specify the URL patterns, HTTP methods, request parameters, headers, and media types that a particular controller method can handle.
HandlerAdapter: 
	Once the DispatcherServlet identifies the target controller method, it uses a HandlerAdapter (like RequestMappingHandlerAdapter) to actually invoke that method. The HandlerAdapter is responsible for handling argument resolution, return value handling, and other aspects of method execution.
The paths specified by the @RequestMapping annotation are managed internally via the HandlerMapping interface.


difference in  == and .equals
== is used to compare references
.equals is used to compare contents


A scenario where .equals give false result and == gives true result.
string s1 = "Hello";
string s2 = "Hello";
if(s1 == s2) ==> True;
String s1 = "Hello";
String s2 = new String("Hello");
if(s1.equals2) = True;


Java Memory model -
It is related to thread management.
It is a abstraction that manages how threads interact through memory and how data is read from and return to main memory.

How many types of memory management is there in java?
5
Heap memory mamangement :
		It is uses for dynamic memory allocation of java objects and jre classes. It is managed by the garbase collectors so it automatically freeze up the memory used by the objects that are no longer reachable.
		Heap memory is complex one.
String/string pool, and objects gets stored in heap memory.
Stack memory mamangement :
		It is used for function/method execution and storing local variables. So method call information and reference to the objects are also stored in this stack memory. memory is allocated and deallocated as Last Int First Out (LIFO)Manner automatically when method are called and returned.
Program gets executed by the stack memory.
		Stack is faster to access coz stack has direct support from CPU with stack pointers
Method Area
PC registers
Native method stack


If you get OutOfMemoryError in production then how you debug?
	If it is OutOfMemoryError it means the heap space is exhausted so there is no more memory in the heap memory.
	We will try to understand the error then we will check the jvm heap setting like we can maximze the size-X ms, in this way we can maximize the heap size
	We can configure JVM and give some path where the heap dump can be generated.
	We can use visual VM for analysing of heap dump and then in that tool we will try to look for any object which is consuming large amount of memory.
	We will also check for any kind of memory leak is not there in code.
	



Java Memoory Management-?


explian abstraction in java?
Abstraction is where u share the relevant details with the client of the class and u hide the irrelevant details so u just share the details which is required for the client.
eg -> u r making a call from one of the class so u just give the method name and the parameters cosider the sorting, so u get list in the sorting method and how the sorting happens that is abstracted.

How do u achieve abstraction?
There r 2 ways for achieving abstraction -
1. using abstract class
2. using interface
I generally used interface for abstraction in java 


what is interface?
Interface is a contract where the class that implements interface has to bind the interface 

Suppose we have final variable(Final in a = 20;) so can you assing it to another variable?
Yes, we can assign its value to another variable like int b = a;
But we cannot change the value of "a".
So assignment can be done but the value cannot be changed.


Use of Final keyword-
It is used to make class immutable.
If we declare a variable as final then we cannot change its value.
It can be used in immuatbility of a variable as well.
It is basically used for implementation of immutability.


How to make immutable class(FPN)-
First declare class as final.
we can declare the variables as private and final.
Then implement getter method only not setter method.
1.Final class, Final fields
2.Private fields(encapsulation)
3.No setter methods/Functions.
4.Defensive copy if mutable object present.
eg -
import java.util.Collections;
import java.util.HashSet;
import java.util.Objects;
import java.util.Set;

public final class MyCar {

    private final String model;
    private final Set<String> machineParts; // Using a Set for machine

    public MyCar(String model, Set<String> machineParts) {
        this.model = model;
        // Defensive copy for mutable Set in the constructor
        this.machineParts = new HashSet<>(machineParts); 
    }

    public String getModel() {
        return model;
    }

    public Set<String> getMachineParts() {
        // Defensive copy for mutable Set in the getter
        return Collections.unmodifiableSet(new HashSet<>(this.machineParts)); 
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        MyCar myCar = (MyCar) o;
        return Objects.equals(model, myCar.model) &&
               Objects.equals(machineParts, myCar.machineParts);
    }

    @Override
    public int hashCode() {
        return Objects.hash(model, machineParts);
    }

    @Override
    public String toString() {
        return "MyCar{" +
               "model='" + model + '\'' +
               ", machineParts=" + machineParts +
               '}';
    }
}


How to make Singleton class(PPG)-
1.Private static instance
2.Private constructor
3.Get instance method
 eg -
 public class MyCar {

    // Private static instance of the class
    private static MyCar instance;

    // Private variable to hold the machine name
    private String machine;

    // Private constructor to prevent direct instantiation
    private MyCar(String machine) {
        this.machine = machine;
    }

    // Public static method to get the single instance of the class
    public static MyCar getInstance(String machine) {
        if (instance == null) {
            instance = new MyCar(machine);
        }
        return instance;
    }

    // Getter for the machine variable
    public String getMachine() {
        return machine;
    }

    // Setter for the machine variable (optional, depending on immutability needs)
    public void setMachine(String machine) {
        this.machine = machine;
    }

    // Example usage
    public static void main(String[] args) {
        // Get the first instance
        MyCar car1 = MyCar.getInstance("Engine A");
        System.out.println("Car 1 machine: " + car1.getMachine()); // Output: Engine A

        // Try to get another instance with a different machine name
        MyCar car2 = MyCar.getInstance("Engine B");
        System.out.println("Car 2 machine: " + car2.getMachine()); // Output: Engine A (still the first instance)

        // Modify the machine of the single instance
        car1.setMachine("Engine C");
        System.out.println("Car 1 machine after modification: " + car1.getMachine()); // Output: Engine C
        System.out.println("Car 2 machine after modification: " + car2.getMachine()); // Output: Engine C
    }
}



Explain exception handling(Checked, unchecked)
Exception handling is a mechanism to handle the errors and exception that occur in our program.
we have checked and unchecked exceptions
Unchecked Exceptions : are the runtime exceptions which can be handled using the throw keyword.
Checked Exceptions : are the compiled time exception this we can handle using the try catch block

What is CustomException explain?
To create custom exception we can extend RunTimeException and we can define constructor to accept the messages.
In Spring boot we can use @ControllerAdvice with @ExceptionHandler to handle the exception globally and once this is done then we can return structure response with message and timeStamp.

Explain Exception Hierarchy?
Throwable class :
1. Exception											2. Error(we cannot handle)i.e irrecoveable situation[OutOFMemory, StackOverFlow error]
i. Checked(CompileTime)  	ii.Unchecked(RunTime)[ArrayOutOfBoundExcptn, NullPointerExceptn, AsymmetricExcptn] i.e it cannot be defined pre i.e not during compile time but happens at runtime
(inputOutPut, SQLException, FileNotFoundExcptn)


Suppose any error happens in the finally block then what happens or how it is different from normal exception like we use try and catch block to handle exception ?
If any exception happens at finally block in that case whatever the exception has been generated in finally block that will be overriden on top of any exception that has happened earlier.
So it will suppress the other exception and final exception will be shown which has happened in the finally block. So we will not be able to know what has happened earlier, before the finally block.
Note : for getting suppressed exception we can use try with resource and call getSuppressed() method, this method came in java 7.

How to handle where a method throws multiple types of exception-
We can use throws keyword here and mention different types of exception-
Or we can write multiple catch blocks here.

Throw vs Throws?
Throws : It is only required for unchecked exceptions or at compile time exception
		We write in method signature itself like throws ExceptionName
		It is used to declare the exception at method signature that this mehtod can throw exception.
Throw : We forcefully throw an error and it should be prefered at runTime exception or custom exceptions.
		We write inside the method body
		It is explicitly used to throw an exception from a method or any block of code. 

Suppose we have Class A, Class B, Class C and class B extend class A, class C extend class B that means class A is super class, class B is child of A and class C is child of B.
Then how you will handle exception, and suppose we write first catch block as C then we write B then we write A?
So do u think it will work or it will create problem.
		In this scenario first we will catch the child class exception first i.e C and then B and then A.
		So basically we first handle most specific exception first so here child C is the most child one so that exception handle first then B exception will be handled and then A exception will be handled.
		If we reorder then it will throw compilation error.


Consider a scenario where u need to choose SQL or NOSQL database then how u will choose?
SQL means ur data must be in structured manner
NOSQL means u can store the data which is not in structured manner
So we need to decide what kind of data we have means whether u r sure about number of columns if yes then SQL database if not sure then NOSQL database
consider below factors-
	data model
	consistency requirement
	how complex is the database(Entity)
	
	
How we manage database Schema like we have changes in schema then how we manage? is there any tool?
U can use tools like flyway or liquibase
Tools are basically used to write migration steps
U can even automate this migration steps as a part of your continuous integration continuous development/deployment pipelines so these tools can be used to manage these changes in ur database schema


what is unique constraint in datbase?
It indicate that the record is unique, it is basically applied on a column which will indicate that the value in that column is unique
so any other record cannot have the same value for that column.
A UNIQUE constraint in a database is a rule applied to a column or a set of columns in a table that ensures all values in that column or combination of columns are distinct. This means no two rows in the table can have the same value(s) in the constrained column(s).



JUnit test cases-

How u do testing-
we have performed sanity testing or unit testing so we have a document where all test cases are written.


explain maven, what maven is and why we use maven?
Maven is a central repository which has all the dependencies
We use maven so that whatever dependencies we need, we mention it in our pom.xml file and when we build our code then maven will first check in our remote repository that dependencies are present or not and if it is not present then it will download it from central repository for us.


Difference between maven clean and maven install-
Maven clean is used to clean the previous build that we have had
Maven install is used to install and build the whole application again.

Few shortcuts of STS-
for debugging code we are using ctrl+shift+i to know the value of the variable.
ctrl+shift+f to make the code in a proper format.
ctrl+click to reach the end of the method/loop/class.

Which git collaboration tool u r using-
AWS 

GIT commands to resolve conflict-
We resolve it manually as we have in our code written as "head" and ">>" so what ever is between this is our previous code and the downword which is below ">>" is current code
So based on these(arrow and head) whatever we want to remove or add we accordingly manage it; and then we add it.


Difference between gitRebase and gitMerge-
When we are merging then gitMerge has the previous history and current history as well
But when we do using gitRebase it just maintain the liner history but not the previous one.

What is gitCherryPic-
When we have lot of commit but we have to take only specific one commit ahead so we use cherrypick
so its like git add only.


Write a code Using JavaStream to convert the given string into uppercase-

String uppercaseString = originalString.chars() // Get an IntStream of character codes
                                               .mapToObj(c -> (char) c) // Convert IntStream to Stream<Character>
                                               .map(Character::toUpperCase) // Map each character to its uppercase equivalent
                                               .map(String::valueOf) // Convert each Character back to a String
                                               .collect(Collectors.joining()); // Join the individual strings back into one

Java code to find evenodd?
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

        1. List<Integer> evenNumbers = numbers.stream()
                                         .filter(n -> n % 2 == 0)
                                         .collect(Collectors.toList());

        List<Integer> oddNumbers = numbers.stream()
                                        .filter(n -> n % 2 != 0)
                                        .collect(Collectors.toList());
2.Map<Boolean, List<Integer>> evenOddMap = numbers.stream()
                                                      .collect(Collectors.partitioningBy(n -> n % 2 == 0));
3. List<String> results = numbers.stream()
                                     .map(n -> n + " is " + (n % 2 == 0 ? "Even" : "Odd"))
                                     .collect(Collectors.toList());

Adv of spring over springboot-
Spring initializer present in springboot.
configurations present in springboot.
embeded server present in springboot.

Most common Annotations you have used and their purposes-
@SpringBootApplication -> used over main method of springboot application; it's a combination of @enableautoconfiguration, @Configuration, @ComponentScan(where beans/components are located; it takes one parameter as input like package name)
@RestController -> It's used over controller layer to route the API's to their end points.
@getmapping, @putmapping, @postmapping, @deletemapping  -> These requests are used to serve the https request like get,put,post,delete.
@Autowired -> To inject the beans
etc.

How you handle exception in springboot application/global exception handler-
You can create a class globalexceptionhandler and annotate it using @RestControllerAdvice(used to handle exception at rest layer)
Inside this method return ResponseEntity
for eg u can use @ExceptionHandler Annotation for httpStatus.NOTFound ( resource not found exception)
So you can basically use @RestControllerAdvice (@ControllerAdvice) along with @ExceptionHandler, (@ResponseStatus for @controllerAdvice) to handle all exceptions
In Spring boot Exception can be handled in 3 ways-
1. Default exception handling by Spring Boot
2. Using @ExceptionHandler annotation
3. Using @ControllerAdvice for global exception handling


different status code-
404 -> API/Resource is not found
401 -> InValid Authorisation
502 -> Issue with server
403 -> Forbidden
200 -> Everything is OK
1xx Informational: 100 Continue
2xx Success: 200 OK, 201 Created, 204 No Content
3xx Redirection: 301 Moved Permanently, 302 Found, 304 Not Modified
4xx Client Error: 400 Bad Request, 401 Unauthorized, 403 Forbidden, 404 Not Found
5xx Server Error: 500 Internal Server Error, 502 Bad Gateway, 503 Service Unavailable


Scenario to develop a rest API and fetch data from db so explain how you will code-
put dependecy in pom.xml for database
database connection related properties like database URL, username, password, driver define/mention it in Application.property file
Then in Java code define - controller, service, DAO/Repository Layers.
In side Controller layer write - getmapping or endpoints which needs to be executed, and call service layer then call DAO/repositor layer.
In side Repository layer you can perform CRUD operations by using JPA repository.
suppose you need single record from database then use FindById function of JPA and then map this result to a bean which want to send it as a part of response.


Difference between PUT and Patch?
1.Scope of Update: PUT replaces the entire resource; PATCH applies partial modifications.
2.Data Sent: PUT sends a complete resource representation; PATCH sends only the changes.
3.Idempotency: PUT is idempotent; PATCH is not always idempotent.
4.Efficiency: PATCH is generally more efficient for partial updates due to less data transfer.











































heartbeat
notification system in springboot application
java email
tools used in springboot for database migration are - flyway and liquibase.
























In core we have - bean configuration for proprty values of external, AOP, db configuration
Note- in core we have authenticationfilter class to do filter once(OncePerRequestFilter - springboot)
Also here we have used AOP(Aspect)


In dao we have - interfaces for CRUD operations

In dao impl we have - impl of interfaces of dao(CRUD operation) with the help of repository pkg/class or JPA CRUD operations is being performed

used serializable

In dto we have - private variables with their getter and setters

In entity we have - implemented serializable, written table name, schema name, columns declaration, getters and setters for the same columns

In mapper we have - toEntity method to save details coming from serviceimpl, toDto method to get data needed in servicimpl class

In repository we have - used @repository, @query, @transactional.... etc jpa or manual query is written for CRUD oparations on data with the help of entity class

In service we have - writtten the services interface (CRUD operations)

In service impl we have - written implementation of service interface (CRUD operations) with the help of dto(request), mapper, entity	; it does its complete implementation by using daoimpl

Generated otp using cache tokens


		








































loggers and its types.... custom logger

AOP - Spring
@exceptiononproperty, @executiononExpression annotation-
@PostConstruct
@JsonAutoDetect.... used in getter setter
@JsonDeserialize.... used in getter setter
@JsonSerialize.... used in getter setter
@JsonInclude(Include.NON_NULL).... used in getter setter
@NotEmpty
@valid
@Modifying
@Transactional
@Transactional(rollbackForClassName
@Transactional(readOnly = false)
@Transactional(transactionManager
@Transactional(timeout = 2)
SAGA pattern is used for transactional condition for rollback.
@Query
@Resource
@RequestBody
@ControllerAdvice
@SuppressWarnings
@ConditionalOnExpression
(Exception handling and its annotation)
@JsonProperty
eg ->
 public class Product {
        @JsonProperty("product_id")
        private String productId; 
        // ... getters and setters
    }
In this example, the productId field in Java will be serialized to product_id in JSON.
// Controlling Serialization/Deserialization:
It can be used to include or exclude fields or methods during the serialization and deserialization processes, providing granular control over data binding.
// The @JsonProperty annotation can be applied to:
Fields: Directly on a field within a Java class to define its corresponding JSON property name.
Getter Methods: On a getter method to control the serialization of the property.
Setter Methods: On a setter method to control the deserialization of the property.
Constructor Parameters: In conjunction with @JsonCreator, to map JSON properties to constructor parameters during object creation.








	
loadbalancer
sync and async service/API call
service mapping (1 to 1 call)
edureka server
profile creation
api gateway
method reference
cache
session

cloud - aws, azure
container - docker, kubernetes
messaging - kafka
Join(), join query/criteria
In code we have written two times left join in 1 query->
from yono_db.REKYC_CUSTOMER_INFO info " + 
			"left join yono_db.REKYC_CUSTOMER_ADDRESS adr on info.YONO_REF_NUMBER=adr.YONO_REF_NUMBER " +	
			"left join yono_db.REKYC_VCALL_DETAILS vcall on info.YONO_REF_NUMBER=vcall.YONO_REF_NUMBER " + 
			"where date(info.UPDATEDDATETIME) = :requestDate or date(info.CREATEDDATETIME) = :requestDate ";
			
			
			


Predicate => it returns true or false.
Annonymous inner class
Map reduce => 
Parralel stream



******************************************************************************************************************************
**********************************Hibernate**********************************************************

JPA and Hibernate->

ORM(Object Relational Mapping) is a tool => mapping java objects to the database tables

JDBC vs JPA vs Hibernate ::
JDBC -> Direct database interaction using SQL
JPA -> its a API specification for ORM(used by Hibernate, EclipseLink, etc); now it is renamed as Jakarta Persistance API
Hibernate -> Popular JPA implementation with advanced features; used in caching, dialect support, etc.

Hibernate Architecture::
Session factory-> 
	we create session factory once in a application as it is heavy object and can be used for whole application.
	session factory is heavy object and it is singleton in nature and used for creating sessions in a application.
Session->
	session interacts with db and session is created from session factory.
	it is light weight and short lived so it can be created and used multiple times.
Transaction->
	with the help of session we can open transaction and connect and perform - commit,rollback.
	we close the transaction after performing the operation either by closing the session or by commiting the transaction.
Query & Criteria API->
	These are used to fetch data either through complex or normal query or either by using join or projections
Hibernate config file->
	Here we write configuration of database, hibernate, class that are going to be managed by hibernate.
	This file is sent to hibernate to read and perform operations

Hibernate Workflow::
	1.Load Hibernate configuration file
	2.Create SessionFactory and this session factory should be singleton and should be created only once.
	3.Open a Session
	4.Begin Transaction
	5.Perform CRUD operations
	6.Commit Transaction
	7.Close Session
	No need to close SessionFactoryactory coz it's a singleton object and can used later on as well
	
Note - for creating sessioin factory we are using singleton design pattern

explain transient, persistent and detached in JPA?
There are mainly four main states of the Hibernate Lifecycle :
1.Transient State -> An entity is in the transient state when it is newly created using the new operator and has not yet been associated with a persistence context (e.g., by calling EntityManager.persist())
2.Persistent State -> An entity enters the persistent state when it is associated with a persistence context. This typically happens after calling EntityManager.persist() for a new entity or EntityManager.find() or EntityManager.merge() for an existing entity. Persistent entities are managed by the EntityManager, and their state is synchronized with the database. 
3.Detached State -> An entity transitions to the detached state when it was previously persistent but is no longer associated with a persistence context. This can occur when the EntityManager is closed, the entity is explicitly detached using EntityManager.detach(), or the persistence context is cleared.
4.Removed State ->  when the entity object is deleted from the database then the entity object is known to be in the removed state. It is done by calling the delete() operation. As the entity object is in the removed state, if any change will be done in the data will not affect the database table.

eg -
// Transient State
Employee e = new Employee();     
Session s = sessionFactory.openSession();
e.setId(01);

// Persistent State
session.save(e);

// Detached State
session.close();  // The object is now detached

// Removed State                  
session.delete(e);  // The object is now removed from the database


what is deadlock in JPA?
A deadlock in JPA occurs when two or more transactions are blocked indefinitely, each waiting for a resource that is held by another transaction in the same set. This creates a circular dependency where no transaction can proceed.
Causes of dead lock eg -> Concurrent Access to Shared Resources, Complex Transaction Logic
Strategies to Mitigate Deadlocks in JPA eg -> Minimize Lock Duration, Reduce Transaction Scope: Break down large, complex transactions into smaller
Identify and Analyze Deadlocks: Enable SQL logging in your JPA provider (e.g., eclipselink.logging.level.sql for EclipseLink or openjpa.jdbc.Trace for OpenJPA) to inspect the exact SQL statements causing the issue.

what is(difference between) Lazy and Eager fetching in JPA?
These strategies determine when related data is loaded from the database.
1. Eager Fetching (FetchType.EAGER):
This is the default FetchType in Hibernate. It means that the associated entity will be fetched only when it is accessed for the first time. This can improve performance in cases where the associated entity is not required most of the time. This can be more efficient than eagerly fetching the entity, especially if the entity has a lot of data and is not needed for every use of the parent entity.
eg ->
@Entity
public class Employee {
    @OneToOne(fetch = FetchType.LAZY) OR @ManyToOne(fetch = FetchType.EAGER)// Eagerly loads the Department
    @JoinColumn(name = "address_id")
    private Address address;

    // other fields and methods
}

	
2. Lazy Fetching (FetchType.LAZY):
This FetchType means that the associated entity will be fetched together with the main entity when the main entity is fetched from the database. This can be useful in cases where the associated entity is always required, but can also result in a performance decrease if the associated entity is large and/or has many associations itself.
eg ->
@Entity
public class Employee {
    @OneToOne(fetch = FetchType.EAGER)
    @JoinColumn(name = "address_id")
    private Address address;

    // other fields and methods
}
OR
@OneToMany(mappedBy = "department", fetch = FetchType.LAZY) // Lazily loads Employees
    private List<Employee> employees;	


We have used relationship of::
	@OneToOne(mappedBy = "loanAgainstMFEntity", fetch = FetchType.EAGER, cascade = CascadeType.ALL, orphanRemoval = true):-
			mappedBy => It will handle the mapping with field "loanAgainstMFEntity" without creating a new column/table for this
			fetch => Used to fetch by type eager means direct/automatically we get the result and type lazy(it is of default type) means on demand means we have to call get method to get data.
			cascade => All operations performed on parents will get affected/propagated to its child as well
			orphanRemoval => same operation is performed on child even after we get the updated data from parent
		@JoinColumn(name = "NRO_ACCOUNT_ID", referencedColumnName = "ID"):-
			This JoinColumn is used to handle the relationship with column "NRO_ACCOUNT_ID"
	@one to many
	@many to one



try with reource::
	In this try method resource is passed as an argument in try and the resource automatically gets closed.
We can get the data from table using::
	try with resource - used for creating session.
	1.Relationships - one to one, one to many, many to one, many to many
	2.HQL query
	3.Crieria API
	4.PaginationUsingHQL


******************************************************************************************************************************
********************************** Java Streams**********************************************************

Sttream creates a pipeline for map,filter(intermediate operations), etc
Stream is lazy coz it works only when terminal operation is performed or means when terminal operations hits the intermediate operations.











******************************************************************************************************************************
********************************** Java 8 features **********************************************************

For loop /traditional loop  or stream which one is effective?
for large dataset for loop/traditional is effective
for small amount of data stream is effective

what is stream?
stream is a pipeline which will be used to perform/transform the elements of stream.
suppose, there are many coloured object with multiple shapes; now you want to filter red color with rectangular shape then you can use stream and list and filter functions which are having red colour and then again use filter function which are having rectangle shape.

Itermediate operations and terminal operations in java8?
Intermediate - Used to transform the elements of a stream.eg -> filter, distinct, 
Terminal - It will give you the final result or Used to produce final result from ur stream. eg -> forEach, collect, count, reduce

what are the main advantages of stream API in java 8?
There are various advantages of stream API, main purpose of introducing was using Functional way of programming and code reusability and readability can be achieved. Also we can reduce boiler plate code using stream API. Also it provide various convenient operations like - filter, map, reduce, collect.
So it is very easy to use and handy.
Also stream are lazy evaluated as long as we don't write the terminal operation it is not evaluated until we write that.
So the optimization is very high, and it improves the performance specially whenever we have the large data sets.
We have Parallel processing support as well so it can again perform some operations very much faster way, compare to the traditional way.
Stream API uses generics so that ensures type safety during the data processing so this ultimately helps finding out the errors at compile time rather then the run time



Lambda Expression
Functional Interface
Date Time API
Default method
Static Method
Method Reference
Optional class



Parallel Stream?
Whenever you want to access the data concurrently then we use parallel stream.
Suppose the order of processing is not important for us and we just want to process it as much as faster in that case we can go with the parallel stream.
So basically they use the power of the whatever the CPU course on which it is being processed. so coz of this it processes the things very much faster in case of large data sets.

Disadvantages of parallel stream?
1. Sequence -> If we have to process something in sequence then in that case we cannot use parallel stream.
	eg. 
2. Thread  safety -> If the method called in parallel stream is not thread safe so that can lead o inconsistent or some corrupted result	  
3. Debug -> If we want to debug it, then it is quite difficult coz it sometimes give 1st and 3rd indexes then it can give another index 
4. Number of thread to generate -> it is not in our control for the generation of thread coz it generates the thread automatically based on CPU course.



******************************************************************************************************************************
********************************** Java 17 features **********************************************************
Sealed Class
	for providing restrictions on class inheritance we use sealed keyword and the class which can extend them are written in permis {eg: Sealed class A permits B, C }
	the class which extends sealed class needs to be declared as final or sealed or non sealed {eg: non sealed class B extends A } here non sealed means other class(class D ) can extend class B
	Note:: Sealed interfaces implementing interfaces need to use key word sealed or non sealedbecause final keyword is not allowed for interfaces.
	



Parallel stream.... In parallel it will process the elements.
Methods in parallel stream - 
		














******************************************************************************************************************************
********************************** Java 21 features(10) **********************************************************
Sring Templates

Unnamed Patterns and Variables

Unnamed Classes and Instance Method

Sequenced Collection Interface

Record Patterns

Pattern in switch

Virtual Threads
	Number of thread which you can create depends on your CPU memory is called virtual Threads.
	Virtual Thread is not tied to your os thread or not tied to only one OS Thread.
	Virtual Threads can be used when we need high throughput concurrent Applications.
	Virtual thread do not run code faster then platform thread , it only gives high throughput due to which it can be used.


Sequenced collection:
	 3 new interfaces added in collection in java 21 -> sequenced set, sequenced map, sequenced collection.
	 We can't remember  all collections method to get first and last element of list, queue, etc as they use different methods.
	 Sequenced collections brings uniformaty by adding methods -> addFirst(), addLast(). removeFirst(), removeLast(), reverse(); map.firstEntry(), map.lasttEntry, map.reverse(), map.sequencedKeySet(), etc{for map} to all collections(list, queue, map, etc)
	 
			











******************************************************************************************************************************
********************************** Java 24 features **********************************************************
1. Performance & Memory Management Enhancements
	1. Generational Shenanoah (Experimental)
				Related to GC
	2. Quantum-Resistant Cryptography
	3. Modernizing Java APIs
			1. Ahead of time class loading & Linking
			2. Class File API
			3. Stream Gatheres
			
	4. JVM Changes
			1. Compact Object Headers(Experimental)
			2. Restrict JNI
			3. Disable Security Manager
			
	5. Language & Syntax Enhancements
			1. Primitive Types in instanceof & switch
			2. Scoped Values(Fourth Preview)
			3. Flexible Constructor Bodies
			4. Module Import Declarations(Second Preview)
			5. Linking Run-Time Images without JMODS
			
	6. Structured Concurrency & Threading
			1. Structured Concurrency
			
	7. Deprecations & Removals
			1. Remove windows 32-bit x86 Support
			2. Deprecate 32-bit x86 Port
			
		
			
	








Controller vs restController:
Feature  				@Controller     															@RestController
Primary Use			Traditional web applications with view rendering (MVC)							RESTful web services returning data (APIs)
View Resolution		Supported; returns view names													Not supported; returns data directly
@ResponseBody		Required on methods to return data directly										Implicitly included; not required on methods
Return Type			Typically view names or ModelAndView											Typically data objects (e.g., POJOs) for serialization




@ControllerAdvice 	(Used in @ExceptionHandler):
		* Used for traditional Spring MVC applications where you are primarily returning views, and explicitly add @ResponseBody if you need to return data in specific exception handling scenarios.


		
@RestControllerAdvice  (Used in @ExceptionHandler):
		* Used for Spring RESTful services where the primary goal is to return data, as it implicitly handles the conversion of return values to the response body.



@RequestMapping:
		* It connects incoming HTTP requests to the appropriate Java methods that will handle those requests.
		* It can handle various HTTP methods (GET, POST, PUT, DELETE, etc.) by specifying the method attribute, for example, @RequestMapping(value = "/path", method = RequestMethod.POST)
		* It can be applied on 2 types:
				1.Class Level: When applied to a controller class, it defines a base URI for all methods within that controller. This helps in organizing endpoints and avoiding repetition.
				2.Method Level: When applied to a specific method within a controller, it defines the specific URI for that individual endpoint.
		* HTTP Method Specification: 
					It allows for the specification of the HTTP method (e.g., GET, POST, PUT, DELETE, PATCH) that a particular method should handle. If no method is specified, it defaults to GET.
		* Dynamic URLs: 
					It supports the use of placeholders (e.g., /{id}) in the URL path, enabling the creation of dynamic endpoints that can handle varying input values.
		* Content Type Handling: 
					It can specify the produces and consumes attributes to define the media types (e.g., application/json, application/xml) that the method can produce or consume, respectively.
		* Alternatives: 
					While @RequestMapping is versatile, Spring 4.3 and later versions introduced more specific, method-level shortcut annotations like @GetMapping, @PostMapping, @PutMapping, @DeleteMapping, and @PatchMapping for 
						improved readability and conciseness. These are often preferred for their clarity.



@path:
		* In Spring Boot, the term "@path" most commonly refers to the use of @PathVariable and the context path of the application.
		

@pathvariable (Spring MVC):
		* This annotation is used to extract values from the URI path and bind them to method parameters.
		* @PathVariable relies on @RequestMapping to define the URI template from which it extracts values.
		* @PathVariable is applied to method parameters.
		* eg- In /users/{id}, id would be a @PathVariable representing a specific user's identifier.


		
@requestparam (Spring MVC):
		* Extracts values from the query parameters of a URL. These appear after a question mark (?) in the URL as key-value pairs.
		* Primarily used for optional parameters, filtering, sorting, or pagination. It provides additional, often optional, details about how to retrieve or process a resource
		* eg- In /products?category=electronics&sort=price, category and sort would be @RequestParams
		

@PathVariable vs @RequestParam:	
Feature					@PathVariable											@RequestParam
Data Location			URI Path												Query String
Purpose					Resource identification, mandatory values				Filtering, sorting, optional parameters
URL Structure			Part of the path (e.g., /users/{id})					Key-value pairs after ? (e.g., /users?name=John)
Requirement				Typically required for resource identification			Can be optional, often used with default values
Used					When parameters are mandatory							When parameters are not mandatory	


@queryparam (JAX-RS/Jersey):
		* Extracts values from the query parameters of the URL.
		* Eg - In /products?category=electronics&limit=10, category and limit are query parameters.




		
@pathparam:
		* It is part of the JAX-RS specification for Java/Jakarta EE.
		* It is used to extract values directly from the URL path segments.
		* extracts from the path segments (e.g., /resource/{id})
		

@RequestBody:
		* @RequestBody annotation maps the HttpRequest body to a transfer or domain object, enabling automatic deserialization
		* Commonly used with requests where the payload is in structured formats like JSON or XML.

@ResponseBody:
		* It is typically used with GET methods to write the response body content.

Difference between @RequestBody and @ResponseBody
Paramaters			@RequestBody														@ResponseBody
Purpose			Applicable for the incoming request data.								Applicable for the outgoing response data.
Method body		Used with POST, PUT, PATCH methods to read the request body.			Used with GET methods to write the response body.
Return value	Typically void or a simple type											Typically, a complex object representing the response data
Object			The deserialized object is passed as a method parameter.				The serialized object is returned from the method.
Payloads		Required to read JSON/XML request payloads.								Required to write JSON/XML response payloads.		


@ModelAttribute:
		* This annotation in Spring MVC serves to bind a method parameter or method return value to a named model attribute, which is then exposed to a web view. It can be used in two primary ways:
				1.On a method parameter: @PostMapping("/submitForm")
    public String processForm(@ModelAttribute("userForm") User user) {}
				2.On a method level:  @ModelAttribute("commonData")
    public String getCommonData() {}




@CrossOrigin:
		* Cross-Origin Resource Sharing (CORS)
		* This annotation allows developers to easily manage cross-origin requests for specific handler classes or methods
		* You can apply this annotation to controllers or individual endpoints to define the allowed origins, methods, headers, and other CORS-related settings.
		
		
@Valid:
		* It triggers validation on an object or its properties, ensuring they adhere to defined constraints (e.g., @NotNull, @Size, @Min, @Max, @Pattern).
		* It is particularly useful for validating nested objects within a larger object graph.
		* It is typically placed on method arguments in controllers or service layers to validate incoming data.
		* If validation fails, a MethodArgumentNotValidException is thrown, which can be handled by a global exception handler. 



@NotNull:
		* It is used in Java Bean Validation to enforce constraints on object properties, specifically for strings.
		* @NotNull only checks for the absence of a null value, while @NotBlank provides a stricter validation for strings by also ensuring they contain at least one non-whitespace character.
		

@Entity:
		* 

Stream<Integer> vs Intstream
	???





IntStream
	Stream of primitive integer value.
	

Stream<Integer>
	Stream of integer objects.

Note->
	The list of operations available in IntStream and Stream<Integer> are diffrent.
	
	
	
System.out::println => It is commonly used with functional interfaces, particularly with the forEach method of collections, to concisely print each element.
		System is a class
		Out is a method present in System class of printstream type
		Print/println/printf is a method present in Printstream class
	// Using a lambda expression
        names.forEach(name -> System.out.println(name));

	// Using a method reference to System.out::println
        names.forEach(System.out::println);









@Column(name = "BEN_ACCOUNT_NO")
	@ColumnTransformer(read = "decrypt_char(BEN_ACCOUNT_NO,'" + Utility.ENCRYPTION_KEY + "')", write = "encrypt(?, '"
			+ Utility.ENCRYPTION_KEY + "')")
			
